<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://http://www.laughingtree.cn').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="LaughingTree">
<meta property="og:url" content="http://http//www.laughingtree.cn/page/12/index.html">
<meta property="og:site_name" content="LaughingTree">
<meta property="article:author" content="LiyunZhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://http//www.laughingtree.cn/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>LaughingTree</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LaughingTree</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags<span class="badge">25</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories<span class="badge">30</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://http//www.laughingtree.cn/2019/11/09/2-sat%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LaughingTree">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/2-sat%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">2-sat算法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-09 00:45:46" itemprop="dateCreated datePublished" datetime="2019-11-09T00:45:46+08:00">2019-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-07 17:43:29" itemprop="dateModified" datetime="2020-08-07T17:43:29+08:00">2020-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index">
                    <span itemprop="name">其他</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>2-sat算法为可满足算法中的特例，对于k-sat算法，若k &gt; 2，则问题是一个NP完全问题，但2-sat不是。2-sat问题一般是：每一个集合里都有两个元素，不同集合里的元素之间可能有矛盾，现在要从每一个集合里都取出一个元素作为代表，且取出的元素两两之间没有矛盾</p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p><strong>构图</strong>：记i和i’是同一个集合里的两个元素，则易得如果i和j有矛盾，则选了i就必选j’，选了j就必选i’。如果选了i就必选j’我们就连一条从i到j’的有向边<br><strong>主体思想</strong>：从一个点出发沿着有向边一直走，选择路过的每一个点<br><strong>失败判断</strong>：走到一个点，那个点所在的集合内的两个点都被标记了<br><strong>失败后的处理</strong>：先清空标记，把失败这次的开始节点换成该集合内的另一个节点，如果还失败就说明无解<br><strong>代码</strong>(假设2i - 1和2i是在同一个集合里)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mp[MAXN];</span><br><span class="line"><span class="keyword">int</span> mark[MAXN], ans[MAXN];</span><br><span class="line"><span class="comment">//mark记录在该次遍历中经过的点，用于清除记录(如果失败)，ans就标记的是选中的点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAnother</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//获得该集合内另一点的标号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> ? x + <span class="number">1</span> : x - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> m)</span>   <span class="comment">//m：矛盾对的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mp[arr[i].x].push_back(getAnother(arr[i].y));</span><br><span class="line">        mp[arr[i].y].push_back(getAnother(arr[i].x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n, <span class="keyword">int</span> &amp; len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ans[getAnother(x)]) <span class="comment">//一个集合内有两个点被标记</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[x] = <span class="number">1</span>;</span><br><span class="line">    mark[len++] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mp[x].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfs(mp[x][i], n, len))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">two_sat</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//遍历所有的集合</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!ans[i &lt;&lt; <span class="number">1</span>] &amp;&amp; !ans[(i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            len = <span class="number">0</span>; <span class="comment">//在这次遍历中直到失败/结束访问的节点的个数</span></span><br><span class="line">            <span class="keyword">if</span>(!dfs((i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>, n, len)) <span class="comment">//失败</span></span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="comment">//先清除记录</span></span><br><span class="line">                <span class="keyword">while</span>(len)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans[mark[--len]] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//再从集合内另一个点开始遍历</span></span><br><span class="line">                <span class="keyword">if</span>(!dfs((i &lt;&lt; <span class="number">1</span>), n, len))</span><br><span class="line">                &#123;</span><br><span class="line">                	<span class="comment">//再失败就说明无解</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>有向图中经常会有环，根据上面对边的定义，可以发现环中的每一个元素要么都选要么都不选，而且这个问题中的环都是对称的，我们就可以利用强连通分量把多个形成环的点缩成一个点，减少点数</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://http//www.laughingtree.cn/2019/11/09/%E6%90%9C%E7%B4%A2%E4%B9%8B%E6%9E%9A%E4%B8%BE-%E7%86%84%E7%81%AF%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LaughingTree">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/%E6%90%9C%E7%B4%A2%E4%B9%8B%E6%9E%9A%E4%B8%BE-%E7%86%84%E7%81%AF%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">搜索之枚举(熄灯问题)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-09 00:44:50" itemprop="dateCreated datePublished" datetime="2019-11-09T00:44:50+08:00">2019-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-07 17:43:17" itemprop="dateModified" datetime="2020-08-07T17:43:17+08:00">2020-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/" itemprop="url" rel="index">
                    <span itemprop="name">搜索</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>一个矩阵排列的灯阵，有的是亮的，有的是灭的。每一个灯都有一个按钮，每个按钮都控制五个灯，分别是按钮直接连的灯和这个灯的上下左右各一个灯，例如位于(2, 3)的按钮可以用控制(2, 3)、(1, 3)、(2, 2)、(2, 4)、(3, 3)。按下按钮后其控制的每一盏灯如果是亮的就灭掉，如果是暗的就亮起来。现在给定一个n×m灯阵，求可以把他们都灭掉的方法</p>
<h1 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h1><p>一直以为状压是高深莫测的东西，原来这就是最经典的01状压。状压就是把物体的状态压缩成一个个整型，存储操作起来方便。状压常和其他算法结合，常见的有动态规划、线段树和搜索。这题就是状压加搜索，把亮灯状态压缩成1，暗灯状态压缩成0。</p>
<h1 id="直观思路"><a href="#直观思路" class="headerlink" title="直观思路"></a>直观思路</h1><p>遍历所有的开关操作，验证是否可以关掉所有的灯。但复杂度是O(mn2^mn^)，高得不可接受。虽然这是一个NP完全问题，但我们还是可以尝试降低一点复杂度，使算法更优</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>易知有以下事实：<br>&emsp;1) 一个灯的状态变化偶数次，那个灯的最终状态就和初状态一样；<br>&emsp;2) 第i行中每盏点亮的灯都可以在第i+1行中按对应的按钮来熄灭它<br>由事实1我们可以以知道每个按钮最多按一次<br>由事实1和2我们可以推理如下：<br>&emsp;1) 如果一盏灯是亮的我们就要按奇数次控制它的开关来熄灭它，如果是暗的我们就要按偶数次来维持它暗的性质，所以如果一个点初始时是1，那其四周的点的和要为奇数；否则为偶数，即奇偶性一致<br>&emsp;2) 设记录灯原始状态的数组为lamp，按钮按的次数的数组为push，则有<code>(push[i][j] + push[i][j - 1] + push[i][j + 1] + push[i + 1][j] + push[i - 1][j]) % 2 == lamp[i][j]</code><br>&emsp;3) 由推论2)得<code>push[i][j] + push[i][j - 1] + push[i][j + 1] + push[i + 1][j] + push[i - 1][j] == (2k - 1)lamp[i][j]</code>，可以推出<code>push[i][j] + push[i][j - 1] + push[i][j + 1] + lamp[i][j] + push[i - 1][j] == 2k * lamp[i][j] - push[i + 1][j]</code>由于<code>2k * lamp[i][j]</code>为偶数，所以<code>2k * lamp[i][j] - push[i + 1][j]</code>的奇偶性与 <code>push[i + 1][j]</code>一致，所以有<code>(lamp[i][j] + push[i][j] + push[i][j - 1] + push[i][j + 1] + push[i - 1][j]) % 2 == push[i + 1][j]</code><br>&emsp;4) 我们可以通过第一行的按钮使用状态推出第二行要使第一行全熄灭的状态，直到最后一行<br>由推论4，我们想到了可以推出当运行到最后一行时，以上的所以灯都是熄灭的，因为我们每一行的目标都是使上一行的灯全部熄灭，当又不会影响到再上一行。而推论2又给了我们一个判断最后一行是否熄灭的办法<br><code>注：为什么要用推论2和3：可以在不改变原始数组的情况下得到所要的结果</code><br>由此，我们就想到了优化的办法：枚举第一行的所有操作，推出以下操作，判断是否可行。复杂度就降到了O(mn2^m^)</p>
<h1 id="推理第二行及以下操作并判断是否可行"><a href="#推理第二行及以下操作并判断是否可行" class="headerlink" title="推理第二行及以下操作并判断是否可行"></a>推理第二行及以下操作并判断是否可行</h1><p>有一个优化代码的细节：如果我们从0开始存储，就会遇到要判断是否越界的情况，但如果我们从1开始存储并在末尾留充足的空间，并全部初始化为0就可以都用同一种操作<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lamp[maxn][maxm], push[maxn][maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">guess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//推理第二行及以下操作</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			push[i + <span class="number">1</span>][j] = (push[i][j] + push[i][j - <span class="number">1</span>] + push[i][j + <span class="number">1</span>] + push[i - <span class="number">1</span>][j] + lamp[i][j]) % <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断是否可行</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//最后一行，不必加上下一行的操作</span></span><br><span class="line">		<span class="keyword">if</span>((push[n][i] + push[n][i - <span class="number">1</span>] + push[n][i] + push[n - <span class="number">1</span>][i]) % <span class="number">2</span> != lamp[n][i])</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;   <span class="comment">//返回操作次数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			cnt += push[i][j];</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="枚举第一行的所有状态"><a href="#枚举第一行的所有状态" class="headerlink" title="枚举第一行的所有状态"></a>枚举第一行的所有状态</h1><p>枚举利用二进制的位运算，二进制第i位为1就表示按下按钮，0表示不操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用二进制初始化push数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">importPush</span><span class="params">(<span class="keyword">int</span> binary)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		push[<span class="number">1</span>][i] = binary &amp; <span class="number">1</span>; <span class="comment">//push[1][i]的值就是当前binary的最低位的值</span></span><br><span class="line">		binary &gt;&gt;= <span class="number">1</span>; <span class="comment">//没导入完一个以后就右移一位，把下一位暴露出来，给下一次导入使用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>易知，灯的所有状态从全为0开始，到全为1结束</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">min</span> = <span class="number">-1</span>, ans = <span class="number">-1</span>; <span class="comment">//返回可行且操作数最小的第一行状态(二进制数)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		importPush(i);  <span class="comment">//先导入</span></span><br><span class="line">		<span class="keyword">int</span> temp = guess();</span><br><span class="line">		<span class="keyword">if</span>(temp &gt;= <span class="number">0</span> &amp;&amp; (temp &lt; <span class="built_in">min</span> || <span class="built_in">min</span> &lt; <span class="number">0</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">min</span> = temp;</span><br><span class="line">			ans = i;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//这里读入数据</span></span><br><span class="line">	<span class="keyword">int</span> ans = solve();</span><br><span class="line">	<span class="keyword">if</span>(ans &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"IMPOSSIBLE\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		guess(ans, n, m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>, push[i][<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">" %d"</span>, push[i][j]);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://vjudge.net/problem/POJ-3279" target="_blank" rel="noopener">POJ 3279(Fliptile)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://http//www.laughingtree.cn/2019/11/09/%E6%90%9C%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LaughingTree">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/%E6%90%9C%E7%B4%A2/" class="post-title-link" itemprop="url">搜索</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-09 00:44:05" itemprop="dateCreated datePublished" datetime="2019-11-09T00:44:05+08:00">2019-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-07 17:43:09" itemprop="dateModified" datetime="2020-08-07T17:43:09+08:00">2020-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/" itemprop="url" rel="index">
                    <span itemprop="name">搜索</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="双源BFS"><a href="#双源BFS" class="headerlink" title="双源BFS"></a>双源BFS</h1><p>有两个起点的BFS，注意，在搜索的时候是搜两颗树(虽然通常两颗数在原图中可能最后会相交)，每次搜索都是一棵树搜一层，另一棵树搜一层。搜索时在开始就把两个起点都加入到同一个队列中，根据BFS是树的层次遍历知——只需要依次取出队列的首元素就可以做到轮流搜一层的效果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Node a, Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">    </span><br><span class="line">    q.push(a);</span><br><span class="line">    q.push(b); <span class="comment">//加入同一个队列</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        a = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(...) <span class="comment">//遍历a的子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            ...生成一个a的子节点b</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(judge(b)) <span class="comment">//如果b合法</span></span><br><span class="line">            &#123;</span><br><span class="line">                q.push(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://vjudge.net/problem/FZU-2150" target="_blank" rel="noopener">FZU 2150</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, cnt ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; v;</span><br><span class="line"><span class="keyword">char</span> mp[N][N];</span><br><span class="line"><span class="keyword">int</span> vis[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b.x&gt;<span class="number">0</span> &amp;&amp; b.y&gt;<span class="number">0</span> &amp;&amp; b.x&lt;=n &amp;&amp; b.y&lt;=m &amp;&amp; vis[b.x][b.y]==<span class="number">0</span> &amp;&amp; mp[b.x][b.y]==<span class="string">'#'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">    vis[a.x][a.y]  = vis[b.x][b.y] = <span class="number">1</span>;</span><br><span class="line">    a.cnt = <span class="number">0</span>,b.cnt = <span class="number">0</span>;</span><br><span class="line">    q.push(a);</span><br><span class="line">    q.push(b);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        a = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        ans = a.cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            b.x = a.x + dx[i];</span><br><span class="line">            b.y = a.y + dy[i];</span><br><span class="line">            b.cnt = a.cnt + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(judge(b))</span><br><span class="line">            &#123;</span><br><span class="line">                vis[b.x][b.y] = <span class="number">1</span>;</span><br><span class="line">                q.push(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> kase = <span class="number">1</span>; kase &lt;= T; kase++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;mp[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j] == <span class="string">'#'</span>)</span><br><span class="line">                    v.push_back((Node)&#123;i, j, <span class="number">0</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; v.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = BFS(v[i], v[j]);</span><br><span class="line">                <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> f = <span class="number">1</span>; f &lt;= m; f++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(vis[k][f] == <span class="number">0</span> &amp;&amp; mp[k][f] == <span class="string">'#'</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            ok = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(ok == <span class="literal">false</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ok)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = <span class="built_in">min</span>(ans, tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, kase);</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://http//www.laughingtree.cn/2019/11/09/%E6%A6%82%E7%8E%87DP%E5%92%8C%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LaughingTree">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/%E6%A6%82%E7%8E%87DP%E5%92%8C%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/" class="post-title-link" itemprop="url">概率DP和高斯消元</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-09 00:43:07" itemprop="dateCreated datePublished" datetime="2019-11-09T00:43:07+08:00">2019-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-07 19:48:35" itemprop="dateModified" datetime="2020-08-07T19:48:35+08:00">2020-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="url" rel="index">
                    <span itemprop="name">动态规划</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>常见的问题就是一个点到终点的步数的期望，通常定义状态dp[i][j]表示的是从(i, j)这个点到终点的步数期望，然后有两种情况：</p>
<h1 id="满足无后效性"><a href="#满足无后效性" class="headerlink" title="满足无后效性"></a>满足无后效性</h1><p>就是每个dp值在被用之前就已经确定，就可以直接用递推，利用终点的dp值为0，反推回去，要的结果就是起点的dp值<br>例如<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3853" target="_blank" rel="noopener">HDOJ-3853</a><br>由于只有右或下或原地三种情况，所以dp[i][j]只与dp[i + 1][j]和dp[i][j + 1]有关，满足无后效性。dp[i][j]就是dp[i + 1][j]和dp[i][j + 1]再走一步得到的，所以有<code>dp[i + 1][j] * p[i][j].down + dp[i][j + 1] * p[i][j].right + 2</code>。但是还没完，由于有回到原地的可能，所以以上都是在不回到原地的条件下的，所以这是一个条件概率问题，还要除以不回到原地的概率<code>1 - p[i][j].self</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ans[MAXN][MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">p</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> self, right, down;</span><br><span class="line">&#125; possi[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r, c;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;r, &amp;c))</span><br><span class="line">    &#123;</span><br><span class="line">        rep(i, <span class="number">0</span>, r)</span><br><span class="line">        &#123;</span><br><span class="line">            rep(j, <span class="number">0</span>, c)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>, &amp;possi[i][j].self, &amp;possi[i][j].right, &amp;possi[i][j].down);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        clr(ans, <span class="number">0</span>);</span><br><span class="line">        ans[r - <span class="number">1</span>][c - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = r - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = c - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == r - <span class="number">1</span> &amp;&amp; j == c - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(possi[i][j].self == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans[i][j] = (ans[i + <span class="number">1</span>][j] * possi[i][j].down + ans[i][j + <span class="number">1</span>] * possi[i][j].right + <span class="number">2</span>) / (<span class="number">1.0</span> - possi[i][j].self);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, ans[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="不满足无后效性"><a href="#不满足无后效性" class="headerlink" title="不满足无后效性"></a>不满足无后效性</h1><p>就是各个概率/期望之间形成一个循环，无法通过递归来求解。这时就要把每一个dp[i][j]都设置为一个未知数，对每一个dp[i][j]我们都可以得到一个线性方程，联立所有的线性方程，就可以得到一个n^2^元1次线性方程组，利用高斯消元法解线性方程组就可以得到答案<br>以下n为行数，m为列数，nun为总未知数的数量<br><strong>构造方程组</strong><br>构造方程组之前要先设元，我们设dp数组是从dp[0][0]开始的，就从上到下，从左到右，从x~0~开始设，所以dp[i][j]就被设为<code>i * m + j</code>。我们在下面的方程中移动各个元素的位置，使相同的未知数对齐，在系数矩阵中把他们的系数储存在不同行的同一列，系数矩阵的不同行储存的是不同方程的各个未知数的系数。还有一个常数数组b储存的是所有方程右边的常数<br><img src="/img/概率DP和高斯消元01.jpg" alt="20190518090332900.jpeg"><br><strong>高斯消元</strong><br>高斯消元就是要把系数矩阵化为一个上三角矩阵。高斯消元的过程中每一大步消一个元，总共要消num次元。每一大步的高斯消元又分为三小步：<br><code>稳定化</code>：这一步较为简单，要消第i个元的时候为了防止0系数被做为基础等一系列稳定性考虑，我们把所有i到num个方程中第i号元素系数最大的那个方程放到最上面，变成第i个方程。这里由于0到i - 1号方程已经消元完成，在后续消元时不需要考虑。<br><code>消元</code>：这一步中既要消a也要消b，要分为两次消。由于0到i - 1号已经消元完成，易知i到nun号所有方程的0到i - 1号元素的系数都是0，就没有必要对他们消元，也不能对他们消元。消元的目的是消除第i号元素，所以对于第j号方程的第k个元素的系数矩阵就是<code>a[j][k] -= a[k][j] / a[i][i] * a[i][k]</code>；对于第j号方程的常数矩阵<code>b[j] -= a[j][k] / a[i][i] * b[i]</code><br><code>回代</code>：消元结束后最后一个方程一定是已经解完了的，即只有一个未知数，我们就从最后一个方程往回代，消掉在它上面所有方程中对应的未知数，之后倒数第二个方程也只剩一个未知数，一直循环直到最后。有一个优化就是我们其实不需要修改系数矩阵的数值，和消元类似，我们每次只消一个元，所以就可以确定乘的倍数，而特殊的一点是每次操作都只会影响到我们要消的那个元素，所以每一步消元都不会影响到下一步消元的倍数，而可以预见的，在每一步都走完之后，系数矩阵变为一个对角阵，所以可以不修改系数矩阵。<br>注：系数矩阵和常数矩阵我们一般定义为double，为了防止误差，我们设定偏差值EPS = 1e-8</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gauss</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//稳定化</span></span><br><span class="line">		<span class="keyword">int</span> r = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; num; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">abs</span>(a[j][i]) &gt; <span class="built_in">abs</span>(a[r][i]))</span><br><span class="line">			&#123;</span><br><span class="line">				r = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">abs</span>(a[r][i]) &lt; EPS) <span class="comment">// 绝对值最大的a[r][i]都为0，不用再执行消元了</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(r != i) <span class="comment">// 交换行</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; num; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				swap(a[i][j], a[r][j]);</span><br><span class="line">			&#125;</span><br><span class="line">			swap(b[i], b[r]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//消元</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; num; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">double</span> mul = a[j][i] / a[i][i];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; num; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				a[j][k] -= mul * a[i][k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; num; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			b[j] -= a[j][i] / a[i][i] * b[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//回代</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = num - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">abs</span>(a[i][i]) &lt; EPS)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			b[j] -= a[j][i] / a[i][i] * b[i];</span><br><span class="line">		&#125;</span><br><span class="line">		b[i] /= a[i][i]; <span class="comment">// 化为单位矩阵</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2262" target="_blank" rel="noopener">HDOJ 2262</a></p>
<h1 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h1><p>还有一些比较特殊的，他们一开始看起来不满足无后效性，但是通过不断地迭代变成满足无后效性<br>如：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4089" target="_blank" rel="noopener">HDOJ 4088</a><br>我们定义dp[i][j]表示队伍还剩下i个人，排在第j个时发生事件的概率。<br>1) 当<code>j == 1</code>时，<code>dp[i][j] = p1 * dp[i][j] + p2 * dp[i][i] + p4</code>三项分别表示激活失败留队、失去连接出队、服务器瘫痪<br>2) 当<code>2 ≤ j ≤ k</code>时，<code>dp[i][j] = p1 * dp[i][j] + p2 * dp[i][j - 1] + p3 * dp[i - 1][j - 1] + p4</code>，分别表示第一个人激活失败留队(什么都不变)、失去连接出队(队伍人数不变，但排位前进一名)、激活成功(队伍少一人，排位前进一位)、服务器瘫痪<br>3) 当<code>j &gt; k</code>时，<code>dp[i][j] = p1 * dp[i][j] + p2 * dp[i][j - 1] + p3 * dp[i - 1][j - 1]</code></p>
<p>在计算dp[i][j]时，dp[i - 1][j - 1]都已知了，可以作为常数处理，为了简便，我们记常数为c[j]<br>令p21 = p2 / (1 - p1)<br>p31 = p3 / (1 - p1)<br>p41 = p4 / (1 - p1)<br>则原式可以化简为<br>1) 当<code>j == 1</code>时，<code>dp[i][1] = p21 * dp[i][i] + c[1]</code>········································①<br>2) 当<code>2 ≤ j ≤ k</code>时，<code>dp[i][j] = p21 * dp[i][j - 1] + c[j]</code>·······························②<br>3) 当<code>j &gt; k</code>时，<code>dp[i][j] = p21 * dp[i][j - 1] + c[j]</code>····································③</p>
<p>②和③可以合并为：当<code>j &gt; 1</code>时，<code>dp[i][j] = p21 * dp[i][j - 1] + c[j]</code>···········④<br>看起来好像dp[i][i]会影响到dp[i][j]，形成一个循环，不满足无后效性，但是我们不断用④代入①，最终会得到式子如下：<br><img src="/img/概率DP和高斯消元02.jpg" alt="20190518222358442.jpeg"><br>然后就可以每次先算出$dp[i][1]$再递推</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dp[MAXN][MAXN], c[MAXN], p[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="keyword">double</span> p1, p2, p3, p4;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d%lf%lf%lf%lf"</span>, &amp;n, &amp;m, &amp;k, &amp;p1, &amp;p2, &amp;p3, &amp;p4))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(p4) &lt; EPS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0.00000\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p2 /= <span class="number">1</span> - p1;</span><br><span class="line">        p3 /= <span class="number">1</span> - p1;</span><br><span class="line">        p4 /= <span class="number">1</span> - p1;</span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n + <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p[i] = p[i - <span class="number">1</span>] * p2;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = p4 / (<span class="number">1</span> - p2);</span><br><span class="line">        rep(i, <span class="number">2</span>, n + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c[<span class="number">1</span>] = p4;</span><br><span class="line">            rep(j, <span class="number">1</span>, i + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt;= k)</span><br><span class="line">                &#123;</span><br><span class="line">                    c[j] = p3 * dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + p4;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    c[j] = p3 * dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">double</span> sum = c[<span class="number">1</span>];</span><br><span class="line">            rep(j, <span class="number">2</span>, i + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += c[j] * p[i + <span class="number">1</span> - j];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">1</span>] = sum / (<span class="number">1</span> - p[i]);</span><br><span class="line">            rep(j, <span class="number">2</span>, i + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] * p2 + c[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>, dp[n][m]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://http//www.laughingtree.cn/2019/11/09/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LaughingTree">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96/" class="post-title-link" itemprop="url">最小路径覆盖</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-09 00:42:21" itemprop="dateCreated datePublished" datetime="2019-11-09T00:42:21+08:00">2019-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-07 22:30:50" itemprop="dateModified" datetime="2020-08-07T22:30:50+08:00">2020-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" itemprop="url" rel="index">
                    <span itemprop="name">最短路径</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="半径为k的树上覆盖"><a href="#半径为k的树上覆盖" class="headerlink" title="半径为k的树上覆盖"></a>半径为k的树上覆盖</h1><p>在一棵树上，每条边的权值都为1，覆盖半径为k<br>用贪心，从最深的节点开始，如果没有被覆盖就把它的第k代祖先覆盖，并更新。<br>一个结构体存储两个值：编号和深度，利用深度排序之后再按编号顺序贪心；<br>dist数组：存储每个结点最近的覆盖点的距离<br>father数组：存储每个结点的父节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(arr + <span class="number">1</span>, arr + <span class="number">1</span> + n, cmp);</span><br><span class="line">    clr(dist, MINF);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sel = arr[i].id;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新当前贪心节点的最近覆盖距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = father[sel], cnt = <span class="number">1</span>; cnt &lt;= k &amp;&amp; j != <span class="number">0</span>; j = father[j], cnt++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="comment">// 距离为上i代祖先的最近覆盖距离，再加上从该祖先到该点的距离</span></span><br><span class="line">            dist[sel] = min(dist[sel], dist[j] + cnt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果最近的覆盖距离大于k，说明没有被覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (dist[sel] &gt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++; <span class="comment">// 增加一个覆盖点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = sel, cnt = k; cnt &gt;= -k &amp;&amp; j != <span class="number">0</span>; j = father[j], cnt--)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = min(dist[j], <span class="built_in">abs</span>(cnt));</span><br><span class="line">                <span class="comment">// 更新当前贪心点上k代祖先的下k代和上k代之内的所有直系覆盖范围</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在更新距离的时候，更新的是直系的距离，实际上k代祖先的后代可以不更新，因为后代只有：1、已经访问过的不会再访问；2、稍后访问，访问时会自动更新(旁系后代的更新方式)<br>例题：<br><a href="https://www.luogu.org/problemnew/show/P3942" target="_blank" rel="noopener">洛谷 P3942</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://http//www.laughingtree.cn/2019/11/09/%E6%AC%A1%E7%9F%AD%E8%B7%AF%E3%80%81k%E7%9F%AD%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LaughingTree">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/%E6%AC%A1%E7%9F%AD%E8%B7%AF%E3%80%81k%E7%9F%AD%E8%B7%AF/" class="post-title-link" itemprop="url">次短路、k短路</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-09 00:41:12" itemprop="dateCreated datePublished" datetime="2019-11-09T00:41:12+08:00">2019-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-07 17:43:01" itemprop="dateModified" datetime="2020-08-07T17:43:01+08:00">2020-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" itemprop="url" rel="index">
                    <span itemprop="name">最短路径</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="次短路-纯dij"><a href="#次短路-纯dij" class="headerlink" title="次短路(纯dij)"></a>次短路(纯dij)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, c;</span><br><span class="line">    </span><br><span class="line">    qnode(<span class="keyword">void</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        v = c = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    qnode (<span class="keyword">int</span> val, <span class="keyword">int</span> cost)</span><br><span class="line">    &#123;</span><br><span class="line">        v = val;</span><br><span class="line">        c = cost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> qnode &amp; r) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt; r.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, cost;</span><br><span class="line">    </span><br><span class="line">    edge (<span class="keyword">void</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        v = cost = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    edge (<span class="keyword">int</span> val, <span class="keyword">int</span> c)</span><br><span class="line">    &#123;</span><br><span class="line">        v = val;</span><br><span class="line">        cost = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; e[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dist[MAXN][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    clr(dist, INF);</span><br><span class="line">    priority_queue&lt;qnode&gt; que;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    dist[start][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    que.push(qnode(start, <span class="number">0</span>));</span><br><span class="line">    qnode tmp;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">int</span> u = tmp.v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[u].size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[u][i].v;</span><br><span class="line">            <span class="keyword">int</span> cost = e[u][i].cost + tmp.c;</span><br><span class="line">            <span class="keyword">if</span> (dist[v][<span class="number">0</span>] &gt; cost)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(dist[v][<span class="number">0</span>], cost);</span><br><span class="line">                que.push(qnode(v, dist[v][<span class="number">0</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dist[v][<span class="number">0</span>] &lt; cost &amp;&amp; cost &lt; dist[v][<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v][<span class="number">1</span>] = cost;</span><br><span class="line">                que.push(qnode(v, dist[v][<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="k短路-dij-A"><a href="#k短路-dij-A" class="headerlink" title="k短路(dij + A*)"></a>k短路(dij + A*)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> S,T,K;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,cost;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt;E[N],G[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Anode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,d,all;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Anode &amp;_)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> all==_.all?d&gt;_.d:all&gt;_.all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Anode&gt;Star;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Astar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dis[S]==<span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(S==T)K++;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!Star.empty())Star.pop();</span><br><span class="line"></span><br><span class="line">    Star.push((Anode)&#123;S,<span class="number">0</span>,dis[S]&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!Star.empty())&#123;</span><br><span class="line">        Anode now=Star.top();Star.pop();</span><br><span class="line">        <span class="keyword">int</span> x=now.to;</span><br><span class="line">        <span class="keyword">if</span>(x==T)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt==K)<span class="keyword">return</span> now.d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)E[x].size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> y=E[x][i].to;</span><br><span class="line">            Star.push((Anode)&#123;y,now.d+E[x][i].cost,now.d+E[x][i].cost+dis[y]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://http//www.laughingtree.cn/2019/11/09/%E5%8C%BA%E9%97%B4DP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LaughingTree">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/%E5%8C%BA%E9%97%B4DP/" class="post-title-link" itemprop="url">区间DP</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-09 00:39:46" itemprop="dateCreated datePublished" datetime="2019-11-09T00:39:46+08:00">2019-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-07 17:41:09" itemprop="dateModified" datetime="2020-08-07T17:41:09+08:00">2020-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="url" rel="index">
                    <span itemprop="name">动态规划</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>区间DP的作用就是解决区间内的最优值。通常是化为几个小区间的和。<br><strong>处理方式</strong>：区间[i, j]内的最优值<code>dp[i][j] = max/min(dp[i][k] + dp[k][j] + sth, dp[i][j])</code>枚举所有的区间划分方式k，求得最优值。<br><strong>但是枚举的顺序应该是怎样的呢？</strong><br>首先容易想到的就是枚举区间的两个端点，i、j再枚举其中的k，但是这样不可取，每次枚举的时候已经枚举的都是区间开始端点小于i的区间，显然区间[k, j]还没有枚举过。我们可以发现求区间[i, j]时要用到的两个子区间的长度都是小于待求区间的，所以我们可以想到按区间长度枚举。下面上板子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	这里是合并两个区间的处理</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intervalDP</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt; n; len++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = i + len; j &lt; n &amp;&amp; i &lt; n; i++, j = i + len)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j] + merge());</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://vjudge.net/problem/POJ-3186" target="_blank" rel="noopener">POJ 3186</a><br>定义状态区间[i, j]表示在只有[i, j]时能够取到的最大值，此时要么取头要么取尾，所以取完要么剩下[i + 1, j]，要么剩下[i, j - 1]。原本有n个，还剩j - i + 1个，则当前是取<code>第n - (j - i + 1) + 1 = n - j + i个</code>。所以如果取头，获得的价值就是<code>val[i] * (n - j + i)</code>，如果取尾，就是<code>val[j] * (n - j + i)</code>。所以得到状态转移方程<br><code>dp[i][j] = max(dp[i + 1][j] + val[i] * (n - j + i), dp[i][j - 1] * val[j] * (n - j + i))</code><br>求解顺序：首先对于所有的dp[i][i]，显然只有i元素时能取到的最大值就是val[i]。之后注意到我们需要用的的有下一行和左一个，所以我们的更新顺序因该是从下往上，从左往右更新<br>最后的答案就是dp[1][n] (假设下标是从1开始)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(ele, init, lim) for(int ele = init; ele &lt; lim; ele++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr, init) memset(arr, init, sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> val[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span> (dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val[i]);</span><br><span class="line">            dp[i][i] = val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j] + val[i] * (n - (j - i + <span class="number">1</span>) + <span class="number">1</span>), dp[i][j - <span class="number">1</span>] + val[j] *(n - (j - i + <span class="number">1</span>) + <span class="number">1</span>) );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">1</span>][n]);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模版题：<a href="https://www.luogu.org/problemnew/show/P1880" target="_blank" rel="noopener">洛谷 P1880</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> num[MAXN], sum[MAXN];</span><br><span class="line"><span class="keyword">int</span> dp1[MAXN][MAXN], dp2[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    scInt(n);</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        scInt(num[i]);</span><br><span class="line">        num[n + i] = num[i];</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    repLE(i, n + <span class="number">1</span>, n * <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;n;p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=i+p;(j&lt;n+n) &amp;&amp; (i&lt;n+n);i++,j=i+p)</span><br><span class="line">        &#123;</span><br><span class="line">            dp2[i][j] = INF;</span><br><span class="line">            repLess(k, i, j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp1[i][j] = max(dp1[i][j], dp1[i][k] + dp1[k + <span class="number">1</span>][j] + sum[j] - sum[i - <span class="number">1</span>]);</span><br><span class="line">                dp2[i][j] = min(dp2[i][j], dp2[i][k] + dp2[k + <span class="number">1</span>][j] + sum[j] - sum[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxAns = <span class="number">0</span>, minAns = INF;</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        maxAns = max(maxAns, dp1[i][i + n - <span class="number">1</span>]);</span><br><span class="line">        minAns = min(minAns, dp2[i][i + n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>, minAns, maxAns);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://http//www.laughingtree.cn/2019/11/09/%E6%95%B0%E4%BD%8DDP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LaughingTree">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/%E6%95%B0%E4%BD%8DDP/" class="post-title-link" itemprop="url">数位DP</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-09 00:39:03" itemprop="dateCreated datePublished" datetime="2019-11-09T00:39:03+08:00">2019-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-07 17:44:52" itemprop="dateModified" datetime="2020-08-07T17:44:52+08:00">2020-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="url" rel="index">
                    <span itemprop="name">动态规划</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>从数a到数b之间，满足一定要求的数的个数，这里的要求指数的组成的要求，例如包含4的数的个数等。这种问题最简单的思路就是从a到b一一枚举，对每个数的每一位一一判断，如果满足就加一。但问题是这种问题中的b-a一般会非常大，所以这样会超时。解决方法就是记忆化搜索</p>
<h1 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h1><p>暴力枚举的方法其实是从低位往高位枚举的过程，这不利于定义状态和记忆化。数位DP的本质其实也是暴力枚举，但是因为枚举的方法不同，就很容易定义出状态。数位DP就是从高位往低位枚举，从最高的那位开始，例如要求不含69的数，如果XXX满足要求的有n个，则1XXX、2XXX…的满足要求的数的个数分别都是n个，但6XXX还要判断一下，这时就可以少了很多的判断。我们使用一个二维数组，存储数字(减去前导0)长度为len时此前符合要求和不符合要求时的结果</p>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p>搜索算法采用的是DFS，在函数的参数中要包含多种参数，当前枚举的是第几位和是否有上限是必须要的，其次还有判断是否合法的变量，例如判断不包含4的数就要加一个变量判断是否在更高位出现过4，如果要判断不包含69的数，就要加一个参数判断是否在上一位包含了6，如果是，那这一位就不能包含9。<br /><br><strong>搜索返回条件</strong>：<br /><br>&emsp;1、当前枚举的是第0位的时候就退出循环，因为这时确认且只确认一个有效数，所以返回1<br /><br>&emsp;2、如果此前符合要求且搜索过当前长度，就直接返回dp二维数组的值</p>
<h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number[maxn], dp[maxn][<span class="number">2</span>]; <span class="comment">//number是最大数字</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">bool</span> preIlegal, <span class="keyword">bool</span> hasLimit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) <span class="comment">//数字确定只有一个，直接返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">//当前枚举位没有数字限制，则个数就是之前算过的那个个数。易知，之前没有非法数字的话之后的枚举和之前的数字是没有关系的，都相等；有非法数字的话一般只有一种情况。且这里为了普遍性，dp数组里存储的是没有最大数字限制的种数，如果当次枚举有数字限制就不符合dp数组的定义，就不能使用值</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLimit &amp;&amp; dp[pos][preIlegal])</span><br><span class="line">        <span class="keyword">return</span> dp[pos][preIlegal];</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, <span class="built_in">max</span> = (hasLimit ? number[pos] : <span class="number">9</span>); <span class="comment">//当前位的最大值，有限制就是被原最大数限制</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">max</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (preIlegal &amp;&amp; i == <span class="number">9</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        cnt += dfs(pos - <span class="number">1</span>, i == <span class="number">4</span>, hasLimit &amp;&amp; i == <span class="built_in">max</span>); <span class="comment">//只有在之前就有最大数字限制且当前枚举数为可枚举的最大值时才会在下一轮中有最大数字限制</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasLimit ? cnt : dp[pos][preIlegal] = cnt; <span class="comment">//没有限制就记忆，否则不具备普遍性。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="主算法"><a href="#主算法" class="headerlink" title="主算法"></a>主算法</h1><p>计算方法就是把a的值和b的值做差</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)</span><br><span class="line">	&#123;</span><br><span class="line">		number[k++] = x % <span class="number">10</span>;</span><br><span class="line">		x /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dfs(k - <span class="number">1</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">finalSolve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> solve(b) - solve(a - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：数位dp不能解决包含某种结构的问题，只能解决不包含，所以包含的问题要转化成不包含做</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://http//www.laughingtree.cn/2019/11/09/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E9%A2%98%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LaughingTree">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E9%A2%98%E9%9B%86/" class="post-title-link" itemprop="url">背包问题题集</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-09 00:38:25" itemprop="dateCreated datePublished" datetime="2019-11-09T00:38:25+08:00">2019-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-07 17:44:02" itemprop="dateModified" datetime="2020-08-07T17:44:02+08:00">2020-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="url" rel="index">
                    <span itemprop="name">动态规划</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>物品n种，背包最大容量为m，求背包能装的最大价值</p>
<h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1><p>01背包的特点就是每一件物品要么选，要么不选<br>定义状态dp[i][j]表示的是只考虑前i个物品当最大背包容量为j时能装的最大价值<br>对于第i个物品，如果选的话就是<code>dp[i - 1][j - cost[i]] + weight[I]</code>    ，如果不选的话就是dp[i - 1][j]。就可以得到状态转移方程：<code>dp[i][j] = max(dp[i - 1][j - cout[i]] + weight[i], dp[i - 1][j])</code><br>此时的时间复杂度是O(n <em> m)， 空间复杂度为O(n </em> m)<br>我们观察得：每次利用的dp数组仅仅是上一行的前半段，dp[i][j]要用的只有dp[i - 1][j - cout[i]]，再上一行，再后一个都不用。就可以想到对空间的优化——利用滚动数组，从后往前更新<br>初始化时，只需全部置为0即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> cost weight;</span><br><span class="line">&#125; things[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zeroOne</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= things[i].cost; j--) <span class="comment">//j - things[i].cost大于等于0才有意义</span></span><br><span class="line">		&#123;</span><br><span class="line">			dp[j] = max(dp[j - things[i].cost] + things[i].weight, dp[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>进阶问题</strong>：如果背包一定要装满？dp数组除了dp[0]外都初始化为-INF</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zeroOne</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, -INF, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= things[i].cost; j--) <span class="comment">//j - things[i].cost大于等于0才有意义</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (dp[j] &lt; dp[j - things[i].cost] + things[i].weight)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[j] = dp[j - things[i].cost] + things[i].weight</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><p>完全背包的特点就是每件物品的个数都是不限量的<br>思考01背包为什么不从前往后遍历：假如在dp[k]的时候考虑过了第i件之后，在dp[k + cost[i]]还会再考虑一次第i件，所以从前往后遍历的问题就是重复考虑，01背包是不允许重复的，但完全背包的特点就是重复。所以完全背包可以从前往后遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = things[i].cost; j &lt;= m; j++) <span class="comment">//j - things[i].cost大于等于0才有意义</span></span><br><span class="line">		&#123;</span><br><span class="line">			dp[j] = max(dp[j - things[i].cost] + things[i].weight, dp[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h1><p>多重背包就是每一种物品的个数不定，可能只有一个，也可能有多个<br><strong>朴素算法</strong>：把每一个物品都当成是一个独立的物种，变为01背包<br><strong>优化</strong>：朴素算法在物品个数多的时候时间复杂度太高，我们可以利用二进制压缩状态。例如第i种物品有x个，每个价值y。我们就可以合成1个价值y，2个价值2y，4个价值4y，我们就可以通过取不同的个数的组合，取得所有的个数可能</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> &amp; n, <span class="keyword">int</span> num, <span class="keyword">int</span> val, <span class="keyword">int</span> cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> bind = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		things[n].cost = bind * cost;</span><br><span class="line">		things[n].weight = bind * val;</span><br><span class="line">		n++;</span><br><span class="line">		num -= bind;</span><br><span class="line">		bind &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(num &lt; bind)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(num)</span><br><span class="line">	&#123;</span><br><span class="line">		things[n].cost = num * cost;</span><br><span class="line">		things[n].weight = num * val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二维价值背包"><a href="#二维价值背包" class="headerlink" title="二维价值背包"></a>二维价值背包</h1><p>每一件物品都有一个费用，两个价值，要求两个价值的最大/最小选法。二维费用的价值一般会有一个优先级别，即在价值1最大的情况下，如果价值1相等，就取价值2最大的<br>类似01背包，给dp数组加一维，dp[i][j]表示在背包容量为i，价值1为j时，价值2的值。仿照01背包，遍历容量时要倒序遍历，但遍历价值1的值的时候不必倒序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cost[maxn], value1[maxn], value2[maxn], dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twoDValue</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> value1Limit)</span> <span class="comment">//n为物品种数，m为背包容量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt; <span class="number">0</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = value1[i]; k &lt; value1Limit; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[j][k] = max(dp[j][k], dp[j - cost[i]][k - value1[i]]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h1><p>分组背包的特点就是所有的物品被分入了若干组中，选的时候每个组至多只能选一件。我们可以把分组背包转化为01背包，每一个组变为01背包中的一个物品，然后尝试从中选择一件物品得到的最大价值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> num; <span class="comment">//这个组内的物品个数</span></span><br><span class="line">	<span class="keyword">int</span> weight[MAXN], cost[MAXN];</span><br><span class="line">&#125; arr[MAXK];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">grouped</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> <span class="comment">// k为组数，m为容量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; arr[i].num; l++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (j &lt; arr[i].cost[l])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				dp[j] = max(dp[j], dp[j - arr[i].cost[l]] + arr[i].weight[l]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="有依赖的背包"><a href="#有依赖的背包" class="headerlink" title="有依赖的背包"></a>有依赖的背包</h1><p>有依赖背包的特点就是有主件和附件之分，要买附件就一定要买主件，且不存在某种物品既依赖于一个物体又被另一个物体依赖。对于每一个主件及其附件的组合中，可以是只买主件、一个主件加一个附件……而且这其中只能选择一个方案加入最后的方案，就发现可以把每一个主件内的组合作为一个组，改变为上面的分组背包。但是这样每一个组内的物品种数为2^num^ + 1件(num为附件个数)，导致复杂度有点高，但易知，对于同样花费的物品，我们只会选择其中价值最高的那种方案，所以我们可以对附件做一个01背包，再转化为分组背包求解。有时还可以优化：相同价值的物品，我们只会选择花费最小的那种，可以省下更多的空间，装更多的价值<br>模版题：<a href="https://www.luogu.org/problemnew/show/P1064" target="_blank" rel="noopener">洛谷 P1064</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mainObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">// 附件个数</span></span><br><span class="line">    <span class="keyword">int</span> mainWeight, mainCost; <span class="comment">// 主件的价值和花费</span></span><br><span class="line">    <span class="keyword">int</span> attachWeight[MAXM], attachCost[MAXM];</span><br><span class="line">    <span class="comment">// 先存储的是附件的价值和花费，01背包处理后变为该主件为代表的组内的选择方案</span></span><br><span class="line">    <span class="keyword">int</span> dp[MAXM]; <span class="comment">// 01背包记录</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp; <span class="comment">// 记录当前价值是否已经记录过</span></span><br><span class="line">&#125; arr[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rely</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> n)</span> <span class="comment">// num为主件个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 01背包</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) <span class="comment">// 对每一个主件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].num == <span class="number">0</span>) <span class="comment">// 假如没有附件，该组别就只要加一个主件的方案</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr[i].attachWeight[<span class="number">0</span>] = arr[i].mainWeight;</span><br><span class="line">            arr[i].attachCost[<span class="number">0</span>] = arr[i].mainCost;</span><br><span class="line">            arr[i].num++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        clr(arr[i].dp, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 对每一个附件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].num; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cost = arr[i].attachCost[j];</span><br><span class="line">            <span class="keyword">int</span> weight = arr[i].attachWeight[j];</span><br><span class="line">            <span class="comment">// 注意！要给主件留出空间，所以k从n - 主件花费开始</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = n - arr[i].mainCost; k &gt;= cost; k--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i].dp[k] &lt; arr[i].dp[k - cost] + weight)</span><br><span class="line">                &#123;</span><br><span class="line">                    arr[i].dp[k] = arr[i].dp[k - cost] + weight;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i].num = <span class="number">0</span>; <span class="comment">// 重置组内方案数，重新统计</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - arr[i].mainCost; j++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="comment">// 如果这个价值在之前已经记录过，由于花费越往后越高，不必再记录</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i].mp.count(arr[i].dp[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没记录过且价值不为0</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i].dp[j])</span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="comment">// 记得买附件一定要买主件，所以还要加上主件的价值和花费</span></span><br><span class="line">                arr[i].attachCost[arr[i].num] = j + arr[i].mainCost;</span><br><span class="line">                arr[i].attachWeight[arr[i].num] = arr[i].dp[j] + arr[i].mainWeight;</span><br><span class="line">                arr[i].mp[arr[i].dp[j]] = <span class="number">1</span>; <span class="comment">// 记录</span></span><br><span class="line">                arr[i].num++; <span class="comment">// 方案数加一</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后还要几得把只买一个主件的方案加进去</span></span><br><span class="line">        arr[i].attachWeight[arr[i].num] = arr[i].mainWeight;</span><br><span class="line">        arr[i].attachCost[arr[i].num] = arr[i].mainCost;</span><br><span class="line">        arr[i].num++;</span><br><span class="line">        arr[i].mp.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分组背包</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; arr[i].num; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; arr[i].attachCost[k])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &lt; dp[j - arr[i].attachCost[k]] + arr[i].attachWeight[k])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] = dp[j - arr[i].attachCost[k]] + arr[i].attachWeight[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="求方案种数"><a href="#求方案种数" class="headerlink" title="求方案种数"></a>求方案种数</h1><p>另外开一个一维数组记录方案种数，同样利用滚动数组，有<code>num[j] += num[j - cost[i]]</code>表示考虑前i件时，背包容量为j的方案种数。初始化时只需要设num[0]= 1表示什么都不选也有一种方法。更新方式和对应的背包更新一样，以下以01背包为例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= cost[i]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] += dp[j - cost[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="如果给的值的范围变了"><a href="#如果给的值的范围变了" class="headerlink" title="如果给的值的范围变了"></a>如果给的值的范围变了</h1><p>以上算法的复杂度为O(mn)为背包容量乘以物品种数，但如果给的背包容量可能非常大，但物品的价值范围较小的话上面的算法的时间复杂度显然不够了，这时就要换一种思路：一价值为基础来算花费。定义dp[i][j]表示考虑前i个物品时，价值为j时的最小重量，则有状态转移方程：<code>dp[i][j] = min(dp[i][j], dp[i][j - weight[i]] + cost[i])</code>，这样初始化的时候就要改一下了，全部初始化为INF，表示价值为j目前什么都不考虑是做不到的，或者说要无限个空物品才可以达到；但是j = 0是可达的，方案就是什么都不选，所以dp[0] = 0</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n为物品种数，m为背包容量，maxV为所有物品中的最大价值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> maxV)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fill(dp, dp + n * maxV, INF);</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = n * maxV; j &gt;= weight[i]; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[j] = min(dp[j], dp[j - weight[i]] + cost[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 答案就是最小花费小于背包容量中下标最大的</span></span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n * maxV; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dp[i] &lt;= m)</span><br><span class="line">		&#123;</span><br><span class="line">			ans = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="如果给的物品的价值不是定值"><a href="#如果给的物品的价值不是定值" class="headerlink" title="如果给的物品的价值不是定值"></a>如果给的物品的价值不是定值</h1><p>如果价值不是定值，如这题<a href="https://www.luogu.org/problemnew/show/P1417" target="_blank" rel="noopener">洛谷 P1417</a>，价值和时间有关，就不能直接套用01背包的模版了。01背包遍历物品从1到n表示的是每个物品在轮到被选择之前的所有选择都是正确的，由于01背包价值的固定性，并不在乎选择的顺序。但是这题不同，这题如果之前的选择不够优，就有可能在选择的时候由于暂时的dp值更大而而导致了如贪心算法一样的片面性，所以我们要保证在选择之前的正确性才可以开始按顺序选择。<br>考虑相邻两物品x,y。假设现在已经耗费p的时间，那么x、y先后做的价值：<br><code>a[x] - (p + c[x]) * b[x] + a[y] - (p + c[x] + c[y]) * b[y]</code>(先做x后做y)<br><code>a[y] - (p + c[y]) * b[y] + a[x] - (p + c[y] + c[x]) * b[x]</code>(先做y后做x)<br>为了让先考虑x再考虑y的顺序是最优解，我们就要让先x后y的价值更大，让1式&gt;2式解得：<code>c[x] * b[y] &lt; c[y] * b[x]</code>，先i项已经考虑过的物品就可以合成一个物品，所以我们只需要按这个顺序对物品进行排序，再按顺序求解就可以得到最优解<br>P.S. 最大值不一定出现在最大时间处</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll a, b, c;</span><br><span class="line">&#125; dish[MAXN];</span><br><span class="line">ll dp[MAXT];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(info a, info b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.c * b.b &lt; a.b * b.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, n;</span><br><span class="line">    scTwoInt(t, n);</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;dish[i].a);</span><br><span class="line">    &#125;</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;dish[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;dish[i].c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(dish + <span class="number">1</span>, dish + <span class="number">1</span> + n, cmp);</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        repME(j, t, dish[i].c)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j - dish[i].c] + dish[i].a - dish[i].b * j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    repLE(i, <span class="number">1</span>, t)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = max(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://http//www.laughingtree.cn/2019/11/09/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LaughingTree">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">背包问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-09 00:37:16" itemprop="dateCreated datePublished" datetime="2019-11-09T00:37:16+08:00">2019-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-07 17:43:51" itemprop="dateModified" datetime="2020-08-07T17:43:51+08:00">2020-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="url" rel="index">
                    <span itemprop="name">动态规划</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>物品n种，背包最大容量为m，求背包能装的最大价值</p>
<h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1><p>01背包的特点就是每一件物品要么选，要么不选<br>定义状态dp[i][j]表示的是只考虑前i个物品当最大背包容量为j时能装的最大价值<br>对于第i个物品，如果选的话就是<code>dp[i - 1][j - cost[i]] + weight[I]</code>    ，如果不选的话就是dp[i - 1][j]。就可以得到状态转移方程：<code>dp[i][j] = max(dp[i - 1][j - cout[i]] + weight[i], dp[i - 1][j])</code><br>此时的时间复杂度是O(n <em> m)， 空间复杂度为O(n </em> m)<br>我们观察得：每次利用的dp数组仅仅是上一行的前半段，dp[i][j]要用的只有dp[i - 1][j - cout[i]]，再上一行，再后一个都不用。就可以想到对空间的优化——利用滚动数组，从后往前更新<br>初始化时，只需全部置为0即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> cost weight;</span><br><span class="line">&#125; things[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zeroOne</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= things[i].cost; j--) <span class="comment">//j - things[i].cost大于等于0才有意义</span></span><br><span class="line">		&#123;</span><br><span class="line">			dp[j] = max(dp[j - things[i].cost] + things[i].weight, dp[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>进阶问题</strong>：如果背包一定要装满？dp数组除了dp[0]外都初始化为-INF</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zeroOne</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, -INF, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= things[i].cost; j--) <span class="comment">//j - things[i].cost大于等于0才有意义</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (dp[j] &lt; dp[j - things[i].cost] + things[i].weight)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[j] = dp[j - things[i].cost] + things[i].weight</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><p>完全背包的特点就是每件物品的个数都是不限量的<br>思考01背包为什么不从前往后遍历：假如在dp[k]的时候考虑过了第i件之后，在dp[k + cost[i]]还会再考虑一次第i件，所以从前往后遍历的问题就是重复考虑，01背包是不允许重复的，但完全背包的特点就是重复。所以完全背包可以从前往后遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = things[i].cost; j &lt;= m; j++) <span class="comment">//j - things[i].cost大于等于0才有意义</span></span><br><span class="line">		&#123;</span><br><span class="line">			dp[j] = max(dp[j - things[i].cost] + things[i].weight, dp[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h1><p>多重背包就是每一种物品的个数不定，可能只有一个，也可能有多个<br><strong>朴素算法</strong>：把每一个物品都当成是一个独立的物种，变为01背包<br><strong>优化</strong>：朴素算法在物品个数多的时候时间复杂度太高，我们可以利用二进制压缩状态。例如第i种物品有x个，每个价值y。我们就可以合成1个价值y，2个价值2y，4个价值4y，我们就可以通过取不同的个数的组合，取得所有的个数可能</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> &amp; n, <span class="keyword">int</span> num, <span class="keyword">int</span> val, <span class="keyword">int</span> cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> bind = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		things[n].cost = bind * cost;</span><br><span class="line">		things[n].weight = bind * val;</span><br><span class="line">		n++;</span><br><span class="line">		num -= bind;</span><br><span class="line">		bind &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(num &lt; bind)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(num)</span><br><span class="line">	&#123;</span><br><span class="line">		things[n].cost = num * cost;</span><br><span class="line">		things[n].weight = num * val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二维价值背包"><a href="#二维价值背包" class="headerlink" title="二维价值背包"></a>二维价值背包</h1><p>每一件物品都有一个费用，两个价值，要求两个价值的最大/最小选法。二维费用的价值一般会有一个优先级别，即在价值1最大的情况下，如果价值1相等，就取价值2最大的<br>类似01背包，给dp数组加一维，dp[i][j]表示在背包容量为i，价值1为j时，价值2的值。仿照01背包，遍历容量时要倒序遍历，但遍历价值1的值的时候不必倒序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cost[maxn], value1[maxn], value2[maxn], dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twoDValue</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> value1Limit)</span> <span class="comment">//n为物品种数，m为背包容量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt; <span class="number">0</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = value1[i]; k &lt; value1Limit; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[j][k] = max(dp[j][k], dp[j - cost[i]][k - value1[i]]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h1><p>分组背包的特点就是所有的物品被分入了若干组中，选的时候每个组至多只能选一件。我们可以把分组背包转化为01背包，每一个组变为01背包中的一个物品，然后尝试从中选择一件物品得到的最大价值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> num; <span class="comment">//这个组内的物品个数</span></span><br><span class="line">	<span class="keyword">int</span> weight[MAXN], cost[MAXN];</span><br><span class="line">&#125; arr[MAXK];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">grouped</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> <span class="comment">// k为组数，m为容量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; arr[i].num; l++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (j &lt; arr[i].cost[l])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				dp[j] = max(dp[j], dp[j - arr[i].cost[l]] + arr[i].weight[l]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="有依赖的背包"><a href="#有依赖的背包" class="headerlink" title="有依赖的背包"></a>有依赖的背包</h1><p>有依赖背包的特点就是有主件和附件之分，要买附件就一定要买主件，且不存在某种物品既依赖于一个物体又被另一个物体依赖。对于每一个主件及其附件的组合中，可以是只买主件、一个主件加一个附件……而且这其中只能选择一个方案加入最后的方案，就发现可以把每一个主件内的组合作为一个组，改变为上面的分组背包。但是这样每一个组内的物品种数为2^num^ + 1件(num为附件个数)，导致复杂度有点高，但易知，对于同样花费的物品，我们只会选择其中价值最高的那种方案，所以我们可以对附件做一个01背包，再转化为分组背包求解。有时还可以优化：相同价值的物品，我们只会选择花费最小的那种，可以省下更多的空间，装更多的价值<br>模版题：<a href="https://www.luogu.org/problemnew/show/P1064" target="_blank" rel="noopener">洛谷 P1064</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mainObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">// 附件个数</span></span><br><span class="line">    <span class="keyword">int</span> mainWeight, mainCost; <span class="comment">// 主件的价值和花费</span></span><br><span class="line">    <span class="keyword">int</span> attachWeight[MAXM], attachCost[MAXM];</span><br><span class="line">    <span class="comment">// 先存储的是附件的价值和花费，01背包处理后变为该主件为代表的组内的选择方案</span></span><br><span class="line">    <span class="keyword">int</span> dp[MAXM]; <span class="comment">// 01背包记录</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp; <span class="comment">// 记录当前价值是否已经记录过</span></span><br><span class="line">&#125; arr[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rely</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> n)</span> <span class="comment">// num为主件个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 01背包</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) <span class="comment">// 对每一个主件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].num == <span class="number">0</span>) <span class="comment">// 假如没有附件，该组别就只要加一个主件的方案</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr[i].attachWeight[<span class="number">0</span>] = arr[i].mainWeight;</span><br><span class="line">            arr[i].attachCost[<span class="number">0</span>] = arr[i].mainCost;</span><br><span class="line">            arr[i].num++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        clr(arr[i].dp, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 对每一个附件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].num; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cost = arr[i].attachCost[j];</span><br><span class="line">            <span class="keyword">int</span> weight = arr[i].attachWeight[j];</span><br><span class="line">            <span class="comment">// 注意！要给主件留出空间，所以k从n - 主件花费开始</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = n - arr[i].mainCost; k &gt;= cost; k--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i].dp[k] &lt; arr[i].dp[k - cost] + weight)</span><br><span class="line">                &#123;</span><br><span class="line">                    arr[i].dp[k] = arr[i].dp[k - cost] + weight;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i].num = <span class="number">0</span>; <span class="comment">// 重置组内方案数，重新统计</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - arr[i].mainCost; j++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="comment">// 如果这个价值在之前已经记录过，由于花费越往后越高，不必再记录</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i].mp.count(arr[i].dp[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没记录过且价值不为0</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i].dp[j])</span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="comment">// 记得买附件一定要买主件，所以还要加上主件的价值和花费</span></span><br><span class="line">                arr[i].attachCost[arr[i].num] = j + arr[i].mainCost;</span><br><span class="line">                arr[i].attachWeight[arr[i].num] = arr[i].dp[j] + arr[i].mainWeight;</span><br><span class="line">                arr[i].mp[arr[i].dp[j]] = <span class="number">1</span>; <span class="comment">// 记录</span></span><br><span class="line">                arr[i].num++; <span class="comment">// 方案数加一</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后还要几得把只买一个主件的方案加进去</span></span><br><span class="line">        arr[i].attachWeight[arr[i].num] = arr[i].mainWeight;</span><br><span class="line">        arr[i].attachCost[arr[i].num] = arr[i].mainCost;</span><br><span class="line">        arr[i].num++;</span><br><span class="line">        arr[i].mp.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分组背包</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; arr[i].num; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; arr[i].attachCost[k])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &lt; dp[j - arr[i].attachCost[k]] + arr[i].attachWeight[k])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] = dp[j - arr[i].attachCost[k]] + arr[i].attachWeight[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="求方案种数"><a href="#求方案种数" class="headerlink" title="求方案种数"></a>求方案种数</h1><p>另外开一个一维数组记录方案种数，同样利用滚动数组，有<code>num[j] += num[j - cost[i]]</code>表示考虑前i件时，背包容量为j的方案种数。初始化时只需要设num[0]= 1表示什么都不选也有一种方法。更新方式和对应的背包更新一样，以下以01背包为例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= cost[i]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] += dp[j - cost[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="如果给的值的范围变了"><a href="#如果给的值的范围变了" class="headerlink" title="如果给的值的范围变了"></a>如果给的值的范围变了</h1><p>以上算法的复杂度为O(mn)为背包容量乘以物品种数，但如果给的背包容量可能非常大，但物品的价值范围较小的话上面的算法的时间复杂度显然不够了，这时就要换一种思路：一价值为基础来算花费。定义dp[i][j]表示考虑前i个物品时，价值为j时的最小重量，则有状态转移方程：<code>dp[i][j] = min(dp[i][j], dp[i][j - weight[i]] + cost[i])</code>，这样初始化的时候就要改一下了，全部初始化为INF，表示价值为j目前什么都不考虑是做不到的，或者说要无限个空物品才可以达到；但是j = 0是可达的，方案就是什么都不选，所以dp[0] = 0</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n为物品种数，m为背包容量，maxV为所有物品中的最大价值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> maxV)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fill(dp, dp + n * maxV, INF);</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = n * maxV; j &gt;= weight[i]; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[j] = min(dp[j], dp[j - weight[i]] + cost[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 答案就是最小花费小于背包容量中下标最大的</span></span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n * maxV; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dp[i] &lt;= m)</span><br><span class="line">		&#123;</span><br><span class="line">			ans = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="如果给的物品的价值不是定值"><a href="#如果给的物品的价值不是定值" class="headerlink" title="如果给的物品的价值不是定值"></a>如果给的物品的价值不是定值</h1><p>如果价值不是定值，如这题<a href="https://www.luogu.org/problemnew/show/P1417" target="_blank" rel="noopener">洛谷 P1417</a>，价值和时间有关，就不能直接套用01背包的模版了。01背包遍历物品从1到n表示的是每个物品在轮到被选择之前的所有选择都是正确的，由于01背包价值的固定性，并不在乎选择的顺序。但是这题不同，这题如果之前的选择不够优，就有可能在选择的时候由于暂时的dp值更大而而导致了如贪心算法一样的片面性，所以我们要保证在选择之前的正确性才可以开始按顺序选择。<br>考虑相邻两物品x,y。假设现在已经耗费p的时间，那么x、y先后做的价值：<br><code>a[x] - (p + c[x]) * b[x] + a[y] - (p + c[x] + c[y]) * b[y]</code>(先做x后做y)<br><code>a[y] - (p + c[y]) * b[y] + a[x] - (p + c[y] + c[x]) * b[x]</code>(先做y后做x)<br>为了让先考虑x再考虑y的顺序是最优解，我们就要让先x后y的价值更大，让1式&gt;2式解得：<code>c[x] * b[y] &lt; c[y] * b[x]</code>，先i项已经考虑过的物品就可以合成一个物品，所以我们只需要按这个顺序对物品进行排序，再按顺序求解就可以得到最优解<br>P.S. 最大值不一定出现在最大时间处</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll a, b, c;</span><br><span class="line">&#125; dish[MAXN];</span><br><span class="line">ll dp[MAXT];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(info a, info b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.c * b.b &lt; a.b * b.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, n;</span><br><span class="line">    scTwoInt(t, n);</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;dish[i].a);</span><br><span class="line">    &#125;</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;dish[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;dish[i].c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(dish + <span class="number">1</span>, dish + <span class="number">1</span> + n, cmp);</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        repME(j, t, dish[i].c)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j - dish[i].c] + dish[i].a - dish[i].b * j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    repLE(i, <span class="number">1</span>, t)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = max(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二维价值背包-1"><a href="#二维价值背包-1" class="headerlink" title="二维价值背包"></a>二维价值背包</h1><p><a href="https://vjudge.net/problem/POJ-1015" target="_blank" rel="noopener">POJ 1015</a><br>把所有人获得的得分的d - p作为价值1，d + p作为价值2，每个人的费用都是1。价值1的范围是[-20m, 20m]，所以为了防止dp数组的第二维访问错误，我们要把所有的价值1加20m。又要记录路径，我们可以利用一个二维的vector数组来存储路径，每对一个元素更新值的时候就更新对应的vector</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">20</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXSUB = <span class="number">800</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXM][MAXSUB], diff[MAXN], sum[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path[MAXM][MAXSUB];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, d, p, kase = <span class="number">1</span>;;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) &amp;&amp; n &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        rep(i, <span class="number">0</span>, m + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rep(j, <span class="number">0</span>, MAXSUB)</span><br><span class="line">            &#123;</span><br><span class="line">                path[i][j].<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        rep(i, <span class="number">0</span>, n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p, &amp;d);</span><br><span class="line">            diff[i] = p - d;</span><br><span class="line">            sum[i] = p + d;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        clr(dp, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> add = <span class="number">20</span> * m;</span><br><span class="line">        dp[<span class="number">0</span>][add] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span>  k = diff[i]; k &lt;= <span class="number">2</span> * add; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(k &lt; <span class="number">0</span> || k - diff[i] &gt; <span class="number">2</span> * add)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dp[j - <span class="number">1</span>][k - diff[i]] == <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dp[j - <span class="number">1</span>][k - diff[i]] + sum[i] &gt; dp[j][k])</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[j][k] = dp[j - <span class="number">1</span>][k - diff[i]] + sum[i];</span><br><span class="line">                        <span class="comment">//更新路径</span></span><br><span class="line">                        path[j][k] = path[j - <span class="number">1</span>][k - diff[i]];</span><br><span class="line">                        path[j][k].push_back(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(dp[m][add + state] == <span class="number">-1</span> &amp;&amp; dp[m][add - state] == <span class="number">-1</span>)  <span class="comment">//找出合法的最小价值1</span></span><br><span class="line">        &#123;</span><br><span class="line">            state++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//更新成更大的那个价值2</span></span><br><span class="line">        <span class="keyword">if</span>(dp[m][add + state] &lt; dp[m][add - state])</span><br><span class="line">        &#123;</span><br><span class="line">            state = add - state;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            state = add + state;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ansD = (dp[m][state] - (state - add)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ansP = (dp[m][state] + (state - add)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Jury #%d\n"</span>, kase++);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Best jury has value %d for prosecution and value %d for defence:\n"</span>, ansP, ansD);</span><br><span class="line">        rep(i, <span class="number">0</span>, path[m][state].<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>, path[m][state][i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="背包的本质"><a href="#背包的本质" class="headerlink" title="背包的本质"></a>背包的本质</h1><p>背包问题的本质就是给定一系列物品，对于物品的选与不选的问题。而且物品的选择不会影响到下一个物品的选择范围(就算是分组背包和依赖背包也可以经过变化，变为不影响选择的问题，主要是要与数塔问题进行区分)<br>例题：<a href="https://www.luogu.org/problemnew/show/P1282" target="_blank" rel="noopener">洛谷 P1282</a><br>这题每一套多米诺骨牌就是一个物品，选与不选的问题就是翻与不翻的问题，这就可以转化为一个01背包。但是要注意的是这题翻与不翻可能会出现负价值，所以这题不能用滚动数组(01背包能用滚动数组是因为只与两维都不大于当前的值有关，但这题负价值的存在就导致了第二维还与大于当前的值有关)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">12005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXA = <span class="number">6005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ori[MAXM][<span class="number">2</span>], dp[MAXM][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    scInt(n);</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        scTwoInt(ori[i][<span class="number">0</span>], ori[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    fill(dp[<span class="number">0</span>], dp[<span class="number">0</span>] + MAXN, INF);</span><br><span class="line">    dp[<span class="number">0</span>][MAXA] = <span class="number">0</span>;</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        repLE(j, <span class="number">-5000</span>, <span class="number">5000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> dis = ori[i][<span class="number">0</span>] - ori[i][<span class="number">1</span>];</span><br><span class="line">            dp[i][j + MAXA] = min(dp[i - <span class="number">1</span>][j - dis + MAXA], dp[i - <span class="number">1</span>][j + dis + MAXA] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    repLE(i, <span class="number">0</span>, <span class="number">5000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = min(dp[n][i + MAXA], dp[n][-i + MAXA]);</span><br><span class="line">        <span class="keyword">if</span>(ans &lt;= <span class="number">1e3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h1><p><a href="https://ac.nowcoder.com/acm/contest/911/H" target="_blank" rel="noopener">新疆省赛-H</a><br>这题对每个数只需要考虑2和5的因数个数，把个数记为费用1，因数5的个数记为费用2，求能得到的最多因数2的个数。费用1的界就是k，费用2的界是前i个数中因数5的个数的总和</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repLess(ele, init, lim) for(int ele = init; ele &lt; lim; ele++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repLE(ele, init, lim) for(int ele = init; ele &lt;= lim; ele++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repMore(ele, init, lim) for(int ele = init; ele &gt; lim; ele--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repME(ele, init, lim) for(int ele = init; ele &gt;= lim; ele--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> scInt(to) scanf(<span class="meta-string">"%d"</span>, &amp;to)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> scTwoInt(one, two) scanf(<span class="meta-string">"%d%d"</span>, &amp;one, &amp;two)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> scThreeInt(one, two, three) scanf(<span class="meta-string">"%d%d%d"</span>, &amp;one, &amp;two, &amp;three)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr, init) memset(arr, init, sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc ((o &lt;&lt; 1) + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (o &lt;&lt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">205</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">num</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll a;</span><br><span class="line">    <span class="keyword">int</span> matchFive, matchEven;</span><br><span class="line">&#125; arr[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXN][<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k))</span><br><span class="line">    &#123;</span><br><span class="line">        repLess(i, <span class="number">0</span>, n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;arr[i].a);</span><br><span class="line">            arr[i].matchFive = arr[i].matchEven = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (arr[i].a % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[i].matchEven++;</span><br><span class="line">                arr[i].a /= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (arr[i].a % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[i].matchFive++;</span><br><span class="line">                arr[i].a /= <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        clr(dp, -INF);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        repLess(i, <span class="number">0</span>, n)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += arr[i].matchFive;</span><br><span class="line">            repME(j, k, <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                repME(l, sum, arr[i].matchFive)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j][l] = max(dp[j - <span class="number">1</span>][l - arr[i].matchFive] + arr[i].matchEven, dp[j][l]);</span><br><span class="line">                    ans = max(min(l, dp[j][l]), ans);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LiyunZhang"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">LiyunZhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">175</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liyun Zhang</span>
</div>
<div class="BbeiAn-info">
       浙ICP备 -
    <a target="_blank" href="http://www.miitbeian.gov.cn/" style="color:#000000"  rel="nofollow">19047088号-1</a> <!--a标签中增加nofollow属性，避免爬虫出站。-->|
    <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33011802001835" style="color:#000000;text-decoration:none;padding-left:30px;background:url(https://s1.ax1x.com/2018/09/29/ilmwIH.png) no-repeat left center" rel="nofollow">浙公网安备 33011802001835号</a>      <!--这里将图标作为了背景，以使得能和后面的文字在同一行-->

</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
