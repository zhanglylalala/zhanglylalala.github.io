<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://http://www.laughingtree.cn').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="LaughingTree">
<meta property="og:url" content="http://http//www.laughingtree.cn/page/12/index.html">
<meta property="og:site_name" content="LaughingTree">
<meta property="article:author" content="LiyunZhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://http//www.laughingtree.cn/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>LaughingTree</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LaughingTree</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags<span class="badge">22</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories<span class="badge">28</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://http//www.laughingtree.cn/2019/11/09/%E6%A6%82%E7%8E%87DP%E5%92%8C%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LaughingTree">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/%E6%A6%82%E7%8E%87DP%E5%92%8C%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/" class="post-title-link" itemprop="url">概率DP和高斯消元</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-09 00:43:07" itemprop="dateCreated datePublished" datetime="2019-11-09T00:43:07+08:00">2019-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-07 15:26:30" itemprop="dateModified" datetime="2020-05-07T15:26:30+08:00">2020-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/" itemprop="url" rel="index">
                    <span itemprop="name">ACM</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/Dynamic-Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Dynamic Programming</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>常见的问题就是一个点到终点的步数的期望，通常定义状态dp[i][j]表示的是从(i, j)这个点到终点的步数期望，然后有两种情况：</p>
<h1 id="满足无后效性"><a href="#满足无后效性" class="headerlink" title="满足无后效性"></a>满足无后效性</h1><p>就是每个dp值在被用之前就已经确定，就可以直接用递推，利用终点的dp值为0，反推回去，要的结果就是起点的dp值<br>例如<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3853" target="_blank" rel="noopener">HDOJ-3853</a><br>由于只有右或下或原地三种情况，所以dp[i][j]只与dp[i + 1][j]和dp[i][j + 1]有关，满足无后效性。dp[i][j]就是dp[i + 1][j]和dp[i][j + 1]再走一步得到的，所以有<code>dp[i + 1][j] * p[i][j].down + dp[i][j + 1] * p[i][j].right + 2</code>。但是还没完，由于有回到原地的可能，所以以上都是在不回到原地的条件下的，所以这是一个条件概率问题，还要除以不回到原地的概率<code>1 - p[i][j].self</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ans[MAXN][MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">p</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> self, right, down;</span><br><span class="line">&#125; possi[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r, c;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;r, &amp;c))</span><br><span class="line">    &#123;</span><br><span class="line">        rep(i, <span class="number">0</span>, r)</span><br><span class="line">        &#123;</span><br><span class="line">            rep(j, <span class="number">0</span>, c)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>, &amp;possi[i][j].self, &amp;possi[i][j].right, &amp;possi[i][j].down);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        clr(ans, <span class="number">0</span>);</span><br><span class="line">        ans[r - <span class="number">1</span>][c - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = r - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = c - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == r - <span class="number">1</span> &amp;&amp; j == c - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(possi[i][j].self == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans[i][j] = (ans[i + <span class="number">1</span>][j] * possi[i][j].down + ans[i][j + <span class="number">1</span>] * possi[i][j].right + <span class="number">2</span>) / (<span class="number">1.0</span> - possi[i][j].self);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, ans[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="不满足无后效性"><a href="#不满足无后效性" class="headerlink" title="不满足无后效性"></a>不满足无后效性</h1><p>就是各个概率/期望之间形成一个循环，无法通过递归来求解。这时就要把每一个dp[i][j]都设置为一个未知数，对每一个dp[i][j]我们都可以得到一个线性方程，联立所有的线性方程，就可以得到一个n^2^元1次线性方程组，利用高斯消元法解线性方程组就可以得到答案<br>以下n为行数，m为列数，nun为总未知数的数量<br><strong>构造方程组</strong><br>构造方程组之前要先设元，我们设dp数组是从dp[0][0]开始的，就从上到下，从左到右，从x~0~开始设，所以dp[i][j]就被设为<code>i * m + j</code>。我们在下面的方程中移动各个元素的位置，使相同的未知数对齐，在系数矩阵中把他们的系数储存在不同行的同一列，系数矩阵的不同行储存的是不同方程的各个未知数的系数。还有一个常数数组b储存的是所有方程右边的常数<br><img src="/img/概率DP和高斯消元01.jpg" alt="20190518090332900.jpeg"><br><strong>高斯消元</strong><br>高斯消元就是要把系数矩阵化为一个上三角矩阵。高斯消元的过程中每一大步消一个元，总共要消num次元。每一大步的高斯消元又分为三小步：<br><code>稳定化</code>：这一步较为简单，要消第i个元的时候为了防止0系数被做为基础等一系列稳定性考虑，我们把所有i到num个方程中第i号元素系数最大的那个方程放到最上面，变成第i个方程。这里由于0到i - 1号方程已经消元完成，在后续消元时不需要考虑。<br><code>消元</code>：这一步中既要消a也要消b，要分为两次消。由于0到i - 1号已经消元完成，易知i到nun号所有方程的0到i - 1号元素的系数都是0，就没有必要对他们消元，也不能对他们消元。消元的目的是消除第i号元素，所以对于第j号方程的第k个元素的系数矩阵就是<code>a[j][k] -= a[k][j] / a[i][i] * a[i][k]</code>；对于第j号方程的常数矩阵<code>b[j] -= a[j][k] / a[i][i] * b[i]</code><br><code>回代</code>：消元结束后最后一个方程一定是已经解完了的，即只有一个未知数，我们就从最后一个方程往回代，消掉在它上面所有方程中对应的未知数，之后倒数第二个方程也只剩一个未知数，一直循环直到最后。有一个优化就是我们其实不需要修改系数矩阵的数值，和消元类似，我们每次只消一个元，所以就可以确定乘的倍数，而特殊的一点是每次操作都只会影响到我们要消的那个元素，所以每一步消元都不会影响到下一步消元的倍数，而可以预见的，在每一步都走完之后，系数矩阵变为一个对角阵，所以可以不修改系数矩阵。<br>注：系数矩阵和常数矩阵我们一般定义为double，为了防止误差，我们设定偏差值EPS = 1e-8</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gauss</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//稳定化</span></span><br><span class="line">		<span class="keyword">int</span> r = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; num; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">abs</span>(a[j][i]) &gt; <span class="built_in">abs</span>(a[r][i]))</span><br><span class="line">			&#123;</span><br><span class="line">				r = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">abs</span>(a[r][i]) &lt; EPS) <span class="comment">// 绝对值最大的a[r][i]都为0，不用再执行消元了</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(r != i) <span class="comment">// 交换行</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; num; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				swap(a[i][j], a[r][j]);</span><br><span class="line">			&#125;</span><br><span class="line">			swap(b[i], b[r]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//消元</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; num; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">double</span> mul = a[j][i] / a[i][i];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; num; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				a[j][k] -= mul * a[i][k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; num; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			b[j] -= a[j][i] / a[i][i] * b[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//回代</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = num - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">abs</span>(a[i][i]) &lt; EPS)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			b[j] -= a[j][i] / a[i][i] * b[i];</span><br><span class="line">		&#125;</span><br><span class="line">		b[i] /= a[i][i]; <span class="comment">// 化为单位矩阵</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2262" target="_blank" rel="noopener">HDOJ 2262</a></p>
<h1 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h1><p>还有一些比较特殊的，他们一开始看起来不满足无后效性，但是通过不断地迭代变成满足无后效性<br>如：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4089" target="_blank" rel="noopener">HDOJ 4088</a><br>我们定义dp[i][j]表示队伍还剩下i个人，排在第j个时发生事件的概率。<br>1) 当<code>j == 1</code>时，<code>dp[i][j] = p1 * dp[i][j] + p2 * dp[i][i] + p4</code>三项分别表示激活失败留队、失去连接出队、服务器瘫痪<br>2) 当<code>2 ≤ j ≤ k</code>时，<code>dp[i][j] = p1 * dp[i][j] + p2 * dp[i][j - 1] + p3 * dp[i - 1][j - 1] + p4</code>，分别表示第一个人激活失败留队(什么都不变)、失去连接出队(队伍人数不变，但排位前进一名)、激活成功(队伍少一人，排位前进一位)、服务器瘫痪<br>3) 当<code>j &gt; k</code>时，<code>dp[i][j] = p1 * dp[i][j] + p2 * dp[i][j - 1] + p3 * dp[i - 1][j - 1]</code></p>
<p>在计算dp[i][j]时，dp[i - 1][j - 1]都已知了，可以作为常数处理，为了简便，我们记常数为c[j]<br>令p21 = p2 / (1 - p1)<br>p31 = p3 / (1 - p1)<br>p41 = p4 / (1 - p1)<br>则原式可以化简为<br>1) 当<code>j == 1</code>时，<code>dp[i][1] = p21 * dp[i][i] + c[1]</code>········································①<br>2) 当<code>2 ≤ j ≤ k</code>时，<code>dp[i][j] = p21 * dp[i][j - 1] + c[j]</code>·······························②<br>3) 当<code>j &gt; k</code>时，<code>dp[i][j] = p21 * dp[i][j - 1] + c[j]</code>····································③</p>
<p>②和③可以合并为：当<code>j &gt; 1</code>时，<code>dp[i][j] = p21 * dp[i][j - 1] + c[j]</code>···········④<br>看起来好像dp[i][i]会影响到dp[i][j]，形成一个循环，不满足无后效性，但是我们不断用④代入①，最终会得到式子如下：<br><img src="/img/概率DP和高斯消元02.jpg" alt="20190518222358442.jpeg"><br>然后就可以每次先算出$dp[i][1]$再递推</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e3</span> + <span class="number">50</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dp[MAXN][MAXN], c[MAXN], p[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="keyword">double</span> p1, p2, p3, p4;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d%lf%lf%lf%lf"</span>, &amp;n, &amp;m, &amp;k, &amp;p1, &amp;p2, &amp;p3, &amp;p4))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(p4) &lt; EPS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0.00000\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p2 /= <span class="number">1</span> - p1;</span><br><span class="line">        p3 /= <span class="number">1</span> - p1;</span><br><span class="line">        p4 /= <span class="number">1</span> - p1;</span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n + <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p[i] = p[i - <span class="number">1</span>] * p2;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = p4 / (<span class="number">1</span> - p2);</span><br><span class="line">        rep(i, <span class="number">2</span>, n + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c[<span class="number">1</span>] = p4;</span><br><span class="line">            rep(j, <span class="number">1</span>, i + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt;= k)</span><br><span class="line">                &#123;</span><br><span class="line">                    c[j] = p3 * dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + p4;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    c[j] = p3 * dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">double</span> sum = c[<span class="number">1</span>];</span><br><span class="line">            rep(j, <span class="number">2</span>, i + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += c[j] * p[i + <span class="number">1</span> - j];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">1</span>] = sum / (<span class="number">1</span> - p[i]);</span><br><span class="line">            rep(j, <span class="number">2</span>, i + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] * p2 + c[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>, dp[n][m]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://http//www.laughingtree.cn/2019/11/09/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LaughingTree">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96/" class="post-title-link" itemprop="url">最小路径覆盖</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-11-09 00:42:21 / Modified: 00:42:50" itemprop="dateCreated datePublished" datetime="2019-11-09T00:42:21+08:00">2019-11-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/" itemprop="url" rel="index">
                    <span itemprop="name">ACM</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/Graph/" itemprop="url" rel="index">
                    <span itemprop="name">Graph</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/Graph/Shortest-Path/" itemprop="url" rel="index">
                    <span itemprop="name">Shortest Path</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="半径为k的树上覆盖"><a href="#半径为k的树上覆盖" class="headerlink" title="半径为k的树上覆盖"></a>半径为k的树上覆盖</h1><p>在一棵树上，每条边的权值都为1，覆盖半径为k<br>用贪心，从最深的节点开始，如果没有被覆盖就把它的第k代祖先覆盖，并更新。<br>一个结构体存储两个值：编号和深度，利用深度排序之后再按编号顺序贪心；<br>dist数组：存储每个结点最近的覆盖点的距离<br>father数组：存储每个结点的父节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(arr + <span class="number">1</span>, arr + <span class="number">1</span> + n, cmp);</span><br><span class="line">    clr(dist, MINF);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sel = arr[i].id;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新当前贪心节点的最近覆盖距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = father[sel], cnt = <span class="number">1</span>; cnt &lt;= k &amp;&amp; j != <span class="number">0</span>; j = father[j], cnt++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="comment">// 距离为上i代祖先的最近覆盖距离，再加上从该祖先到该点的距离</span></span><br><span class="line">            dist[sel] = min(dist[sel], dist[j] + cnt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果最近的覆盖距离大于k，说明没有被覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (dist[sel] &gt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++; <span class="comment">// 增加一个覆盖点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = sel, cnt = k; cnt &gt;= -k &amp;&amp; j != <span class="number">0</span>; j = father[j], cnt--)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = min(dist[j], <span class="built_in">abs</span>(cnt));</span><br><span class="line">                <span class="comment">// 更新当前贪心点上k代祖先的下k代和上k代之内的所有直系覆盖范围</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在更新距离的时候，更新的是直系的距离，实际上k代祖先的后代可以不更新，因为后代只有：1、已经访问过的不会再访问；2、稍后访问，访问时会自动更新(旁系后代的更新方式)<br>例题：<br><a href="https://www.luogu.org/problemnew/show/P3942" target="_blank" rel="noopener">洛谷 P3942</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://http//www.laughingtree.cn/2019/11/09/%E6%AC%A1%E7%9F%AD%E8%B7%AF%E3%80%81k%E7%9F%AD%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LaughingTree">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/%E6%AC%A1%E7%9F%AD%E8%B7%AF%E3%80%81k%E7%9F%AD%E8%B7%AF/" class="post-title-link" itemprop="url">次短路、k短路</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-11-09 00:41:12 / Modified: 00:41:54" itemprop="dateCreated datePublished" datetime="2019-11-09T00:41:12+08:00">2019-11-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/" itemprop="url" rel="index">
                    <span itemprop="name">ACM</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/Graph/" itemprop="url" rel="index">
                    <span itemprop="name">Graph</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/Graph/Shortest-Path/" itemprop="url" rel="index">
                    <span itemprop="name">Shortest Path</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="次短路-纯dij"><a href="#次短路-纯dij" class="headerlink" title="次短路(纯dij)"></a>次短路(纯dij)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, c;</span><br><span class="line">    </span><br><span class="line">    qnode(<span class="keyword">void</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        v = c = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    qnode (<span class="keyword">int</span> val, <span class="keyword">int</span> cost)</span><br><span class="line">    &#123;</span><br><span class="line">        v = val;</span><br><span class="line">        c = cost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> qnode &amp; r) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt; r.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, cost;</span><br><span class="line">    </span><br><span class="line">    edge (<span class="keyword">void</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        v = cost = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    edge (<span class="keyword">int</span> val, <span class="keyword">int</span> c)</span><br><span class="line">    &#123;</span><br><span class="line">        v = val;</span><br><span class="line">        cost = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; e[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dist[MAXN][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    clr(dist, INF);</span><br><span class="line">    priority_queue&lt;qnode&gt; que;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    dist[start][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    que.push(qnode(start, <span class="number">0</span>));</span><br><span class="line">    qnode tmp;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">int</span> u = tmp.v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[u].size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[u][i].v;</span><br><span class="line">            <span class="keyword">int</span> cost = e[u][i].cost + tmp.c;</span><br><span class="line">            <span class="keyword">if</span> (dist[v][<span class="number">0</span>] &gt; cost)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(dist[v][<span class="number">0</span>], cost);</span><br><span class="line">                que.push(qnode(v, dist[v][<span class="number">0</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dist[v][<span class="number">0</span>] &lt; cost &amp;&amp; cost &lt; dist[v][<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v][<span class="number">1</span>] = cost;</span><br><span class="line">                que.push(qnode(v, dist[v][<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="k短路-dij-A"><a href="#k短路-dij-A" class="headerlink" title="k短路(dij + A*)"></a>k短路(dij + A*)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> S,T,K;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,cost;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt;E[N],G[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Anode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,d,all;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Anode &amp;_)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> all==_.all?d&gt;_.d:all&gt;_.all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Anode&gt;Star;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Astar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dis[S]==<span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(S==T)K++;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!Star.empty())Star.pop();</span><br><span class="line"></span><br><span class="line">    Star.push((Anode)&#123;S,<span class="number">0</span>,dis[S]&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!Star.empty())&#123;</span><br><span class="line">        Anode now=Star.top();Star.pop();</span><br><span class="line">        <span class="keyword">int</span> x=now.to;</span><br><span class="line">        <span class="keyword">if</span>(x==T)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt==K)<span class="keyword">return</span> now.d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)E[x].size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> y=E[x][i].to;</span><br><span class="line">            Star.push((Anode)&#123;y,now.d+E[x][i].cost,now.d+E[x][i].cost+dis[y]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://http//www.laughingtree.cn/2019/11/09/%E5%8C%BA%E9%97%B4DP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LaughingTree">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/%E5%8C%BA%E9%97%B4DP/" class="post-title-link" itemprop="url">区间DP</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-11-09 00:39:46 / Modified: 00:40:13" itemprop="dateCreated datePublished" datetime="2019-11-09T00:39:46+08:00">2019-11-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/" itemprop="url" rel="index">
                    <span itemprop="name">ACM</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/Dynamic-Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Dynamic Programming</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>区间DP的作用就是解决区间内的最优值。通常是化为几个小区间的和。<br><strong>处理方式</strong>：区间[i, j]内的最优值<code>dp[i][j] = max/min(dp[i][k] + dp[k][j] + sth, dp[i][j])</code>枚举所有的区间划分方式k，求得最优值。<br><strong>但是枚举的顺序应该是怎样的呢？</strong><br>首先容易想到的就是枚举区间的两个端点，i、j再枚举其中的k，但是这样不可取，每次枚举的时候已经枚举的都是区间开始端点小于i的区间，显然区间[k, j]还没有枚举过。我们可以发现求区间[i, j]时要用到的两个子区间的长度都是小于待求区间的，所以我们可以想到按区间长度枚举。下面上板子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	这里是合并两个区间的处理</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intervalDP</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt; n; len++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = i + len; j &lt; n &amp;&amp; i &lt; n; i++, j = i + len)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j] + merge());</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://vjudge.net/problem/POJ-3186" target="_blank" rel="noopener">POJ 3186</a><br>定义状态区间[i, j]表示在只有[i, j]时能够取到的最大值，此时要么取头要么取尾，所以取完要么剩下[i + 1, j]，要么剩下[i, j - 1]。原本有n个，还剩j - i + 1个，则当前是取<code>第n - (j - i + 1) + 1 = n - j + i个</code>。所以如果取头，获得的价值就是<code>val[i] * (n - j + i)</code>，如果取尾，就是<code>val[j] * (n - j + i)</code>。所以得到状态转移方程<br><code>dp[i][j] = max(dp[i + 1][j] + val[i] * (n - j + i), dp[i][j - 1] * val[j] * (n - j + i))</code><br>求解顺序：首先对于所有的dp[i][i]，显然只有i元素时能取到的最大值就是val[i]。之后注意到我们需要用的的有下一行和左一个，所以我们的更新顺序因该是从下往上，从左往右更新<br>最后的答案就是dp[1][n] (假设下标是从1开始)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(ele, init, lim) for(int ele = init; ele &lt; lim; ele++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr, init) memset(arr, init, sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> val[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span> (dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val[i]);</span><br><span class="line">            dp[i][i] = val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j] + val[i] * (n - (j - i + <span class="number">1</span>) + <span class="number">1</span>), dp[i][j - <span class="number">1</span>] + val[j] *(n - (j - i + <span class="number">1</span>) + <span class="number">1</span>) );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">1</span>][n]);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模版题：<a href="https://www.luogu.org/problemnew/show/P1880" target="_blank" rel="noopener">洛谷 P1880</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> num[MAXN], sum[MAXN];</span><br><span class="line"><span class="keyword">int</span> dp1[MAXN][MAXN], dp2[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    scInt(n);</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        scInt(num[i]);</span><br><span class="line">        num[n + i] = num[i];</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    repLE(i, n + <span class="number">1</span>, n * <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;n;p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=i+p;(j&lt;n+n) &amp;&amp; (i&lt;n+n);i++,j=i+p)</span><br><span class="line">        &#123;</span><br><span class="line">            dp2[i][j] = INF;</span><br><span class="line">            repLess(k, i, j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp1[i][j] = max(dp1[i][j], dp1[i][k] + dp1[k + <span class="number">1</span>][j] + sum[j] - sum[i - <span class="number">1</span>]);</span><br><span class="line">                dp2[i][j] = min(dp2[i][j], dp2[i][k] + dp2[k + <span class="number">1</span>][j] + sum[j] - sum[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxAns = <span class="number">0</span>, minAns = INF;</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        maxAns = max(maxAns, dp1[i][i + n - <span class="number">1</span>]);</span><br><span class="line">        minAns = min(minAns, dp2[i][i + n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>, minAns, maxAns);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://http//www.laughingtree.cn/2019/11/09/%E6%95%B0%E4%BD%8DDP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LaughingTree">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/%E6%95%B0%E4%BD%8DDP/" class="post-title-link" itemprop="url">数位DP</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-09 00:39:03" itemprop="dateCreated datePublished" datetime="2019-11-09T00:39:03+08:00">2019-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-29 19:34:34" itemprop="dateModified" datetime="2020-02-29T19:34:34+08:00">2020-02-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/" itemprop="url" rel="index">
                    <span itemprop="name">ACM</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/Dynamic-Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Dynamic Programming</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>从数a到数b之间，满足一定要求的数的个数，这里的要求指数的组成的要求，例如包含4的数的个数等。这种问题最简单的思路就是从a到b一一枚举，对每个数的每一位一一判断，如果满足就加一。但问题是这种问题中的b-a一般会非常大，所以这样会超时。解决方法就是记忆化搜索</p>
<h1 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h1><p>暴力枚举的方法其实是从低位往高位枚举的过程，这不利于定义状态和记忆化。数位DP的本质其实也是暴力枚举，但是因为枚举的方法不同，就很容易定义出状态。数位DP就是从高位往低位枚举，从最高的那位开始，例如要求不含69的数，如果XXX满足要求的有n个，则1XXX、2XXX…的满足要求的数的个数分别都是n个，但6XXX还要判断一下，这时就可以少了很多的判断。我们使用一个二维数组，存储数字(减去前导0)长度为len时此前符合要求和不符合要求时的结果</p>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p>搜索算法采用的是DFS，在函数的参数中要包含多种参数，当前枚举的是第几位和是否有上限是必须要的，其次还有判断是否合法的变量，例如判断不包含4的数就要加一个变量判断是否在更高位出现过4，如果要判断不包含69的数，就要加一个参数判断是否在上一位包含了6，如果是，那这一位就不能包含9。<br /><br><strong>搜索返回条件</strong>：<br /><br>&emsp;1、当前枚举的是第0位的时候就退出循环，因为这时确认且只确认一个有效数，所以返回1<br /><br>&emsp;2、如果此前符合要求且搜索过当前长度，就直接返回dp二维数组的值</p>
<h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number[maxn], dp[maxn][<span class="number">2</span>]; <span class="comment">//number是最大数字</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">bool</span> preIlegal, <span class="keyword">bool</span> hasLimit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) <span class="comment">//数字确定只有一个，直接返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">//当前枚举位没有数字限制，则个数就是之前算过的那个个数。易知，之前没有非法数字的话之后的枚举和之前的数字是没有关系的，都相等；有非法数字的话一般只有一种情况。且这里为了普遍性，dp数组里存储的是没有最大数字限制的种数，如果当次枚举有数字限制就不符合dp数组的定义，就不能使用值</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLimit &amp;&amp; dp[pos][preIlegal])</span><br><span class="line">        <span class="keyword">return</span> dp[pos][preIlegal];</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, <span class="built_in">max</span> = (hasLimit ? number[pos] : <span class="number">9</span>); <span class="comment">//当前位的最大值，有限制就是被原最大数限制</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">max</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (preIlegal &amp;&amp; i == <span class="number">9</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        cnt += dfs(pos - <span class="number">1</span>, i == <span class="number">4</span>, hasLimit &amp;&amp; i == <span class="built_in">max</span>); <span class="comment">//只有在之前就有最大数字限制且当前枚举数为可枚举的最大值时才会在下一轮中有最大数字限制</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasLimit ? cnt : dp[pos][preIlegal] = cnt; <span class="comment">//没有限制就记忆，否则不具备普遍性。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="主算法"><a href="#主算法" class="headerlink" title="主算法"></a>主算法</h1><p>计算方法就是把a的值和b的值做差</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)</span><br><span class="line">	&#123;</span><br><span class="line">		number[k++] = x % <span class="number">10</span>;</span><br><span class="line">		x /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dfs(k - <span class="number">1</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">finalSolve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> solve(b) - solve(a - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：数位dp不能解决包含某种结构的问题，只能解决不包含，所以包含的问题要转化成不包含做</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://http//www.laughingtree.cn/2019/11/09/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E9%A2%98%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LaughingTree">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E9%A2%98%E9%9B%86/" class="post-title-link" itemprop="url">背包问题题集</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-11-09 00:38:25 / Modified: 11:06:47" itemprop="dateCreated datePublished" datetime="2019-11-09T00:38:25+08:00">2019-11-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/" itemprop="url" rel="index">
                    <span itemprop="name">ACM</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/Dynamic-Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Dynamic Programming</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>物品n种，背包最大容量为m，求背包能装的最大价值</p>
<h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1><p>01背包的特点就是每一件物品要么选，要么不选<br>定义状态dp[i][j]表示的是只考虑前i个物品当最大背包容量为j时能装的最大价值<br>对于第i个物品，如果选的话就是<code>dp[i - 1][j - cost[i]] + weight[I]</code>    ，如果不选的话就是dp[i - 1][j]。就可以得到状态转移方程：<code>dp[i][j] = max(dp[i - 1][j - cout[i]] + weight[i], dp[i - 1][j])</code><br>此时的时间复杂度是O(n <em> m)， 空间复杂度为O(n </em> m)<br>我们观察得：每次利用的dp数组仅仅是上一行的前半段，dp[i][j]要用的只有dp[i - 1][j - cout[i]]，再上一行，再后一个都不用。就可以想到对空间的优化——利用滚动数组，从后往前更新<br>初始化时，只需全部置为0即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> cost weight;</span><br><span class="line">&#125; things[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zeroOne</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= things[i].cost; j--) <span class="comment">//j - things[i].cost大于等于0才有意义</span></span><br><span class="line">		&#123;</span><br><span class="line">			dp[j] = max(dp[j - things[i].cost] + things[i].weight, dp[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>进阶问题</strong>：如果背包一定要装满？dp数组除了dp[0]外都初始化为-INF</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zeroOne</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, -INF, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= things[i].cost; j--) <span class="comment">//j - things[i].cost大于等于0才有意义</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (dp[j] &lt; dp[j - things[i].cost] + things[i].weight)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[j] = dp[j - things[i].cost] + things[i].weight</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><p>完全背包的特点就是每件物品的个数都是不限量的<br>思考01背包为什么不从前往后遍历：假如在dp[k]的时候考虑过了第i件之后，在dp[k + cost[i]]还会再考虑一次第i件，所以从前往后遍历的问题就是重复考虑，01背包是不允许重复的，但完全背包的特点就是重复。所以完全背包可以从前往后遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = things[i].cost; j &lt;= m; j++) <span class="comment">//j - things[i].cost大于等于0才有意义</span></span><br><span class="line">		&#123;</span><br><span class="line">			dp[j] = max(dp[j - things[i].cost] + things[i].weight, dp[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h1><p>多重背包就是每一种物品的个数不定，可能只有一个，也可能有多个<br><strong>朴素算法</strong>：把每一个物品都当成是一个独立的物种，变为01背包<br><strong>优化</strong>：朴素算法在物品个数多的时候时间复杂度太高，我们可以利用二进制压缩状态。例如第i种物品有x个，每个价值y。我们就可以合成1个价值y，2个价值2y，4个价值4y，我们就可以通过取不同的个数的组合，取得所有的个数可能</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> &amp; n, <span class="keyword">int</span> num, <span class="keyword">int</span> val, <span class="keyword">int</span> cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> bind = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		things[n].cost = bind * cost;</span><br><span class="line">		things[n].weight = bind * val;</span><br><span class="line">		n++;</span><br><span class="line">		num -= bind;</span><br><span class="line">		bind &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(num &lt; bind)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(num)</span><br><span class="line">	&#123;</span><br><span class="line">		things[n].cost = num * cost;</span><br><span class="line">		things[n].weight = num * val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二维价值背包"><a href="#二维价值背包" class="headerlink" title="二维价值背包"></a>二维价值背包</h1><p>每一件物品都有一个费用，两个价值，要求两个价值的最大/最小选法。二维费用的价值一般会有一个优先级别，即在价值1最大的情况下，如果价值1相等，就取价值2最大的<br>类似01背包，给dp数组加一维，dp[i][j]表示在背包容量为i，价值1为j时，价值2的值。仿照01背包，遍历容量时要倒序遍历，但遍历价值1的值的时候不必倒序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cost[maxn], value1[maxn], value2[maxn], dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twoDValue</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> value1Limit)</span> <span class="comment">//n为物品种数，m为背包容量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt; <span class="number">0</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = value1[i]; k &lt; value1Limit; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[j][k] = max(dp[j][k], dp[j - cost[i]][k - value1[i]]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h1><p>分组背包的特点就是所有的物品被分入了若干组中，选的时候每个组至多只能选一件。我们可以把分组背包转化为01背包，每一个组变为01背包中的一个物品，然后尝试从中选择一件物品得到的最大价值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> num; <span class="comment">//这个组内的物品个数</span></span><br><span class="line">	<span class="keyword">int</span> weight[MAXN], cost[MAXN];</span><br><span class="line">&#125; arr[MAXK];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">grouped</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> <span class="comment">// k为组数，m为容量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; arr[i].num; l++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (j &lt; arr[i].cost[l])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				dp[j] = max(dp[j], dp[j - arr[i].cost[l]] + arr[i].weight[l]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="有依赖的背包"><a href="#有依赖的背包" class="headerlink" title="有依赖的背包"></a>有依赖的背包</h1><p>有依赖背包的特点就是有主件和附件之分，要买附件就一定要买主件，且不存在某种物品既依赖于一个物体又被另一个物体依赖。对于每一个主件及其附件的组合中，可以是只买主件、一个主件加一个附件……而且这其中只能选择一个方案加入最后的方案，就发现可以把每一个主件内的组合作为一个组，改变为上面的分组背包。但是这样每一个组内的物品种数为2^num^ + 1件(num为附件个数)，导致复杂度有点高，但易知，对于同样花费的物品，我们只会选择其中价值最高的那种方案，所以我们可以对附件做一个01背包，再转化为分组背包求解。有时还可以优化：相同价值的物品，我们只会选择花费最小的那种，可以省下更多的空间，装更多的价值<br>模版题：<a href="https://www.luogu.org/problemnew/show/P1064" target="_blank" rel="noopener">洛谷 P1064</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mainObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">// 附件个数</span></span><br><span class="line">    <span class="keyword">int</span> mainWeight, mainCost; <span class="comment">// 主件的价值和花费</span></span><br><span class="line">    <span class="keyword">int</span> attachWeight[MAXM], attachCost[MAXM];</span><br><span class="line">    <span class="comment">// 先存储的是附件的价值和花费，01背包处理后变为该主件为代表的组内的选择方案</span></span><br><span class="line">    <span class="keyword">int</span> dp[MAXM]; <span class="comment">// 01背包记录</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp; <span class="comment">// 记录当前价值是否已经记录过</span></span><br><span class="line">&#125; arr[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rely</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> n)</span> <span class="comment">// num为主件个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 01背包</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) <span class="comment">// 对每一个主件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].num == <span class="number">0</span>) <span class="comment">// 假如没有附件，该组别就只要加一个主件的方案</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr[i].attachWeight[<span class="number">0</span>] = arr[i].mainWeight;</span><br><span class="line">            arr[i].attachCost[<span class="number">0</span>] = arr[i].mainCost;</span><br><span class="line">            arr[i].num++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        clr(arr[i].dp, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 对每一个附件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].num; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cost = arr[i].attachCost[j];</span><br><span class="line">            <span class="keyword">int</span> weight = arr[i].attachWeight[j];</span><br><span class="line">            <span class="comment">// 注意！要给主件留出空间，所以k从n - 主件花费开始</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = n - arr[i].mainCost; k &gt;= cost; k--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i].dp[k] &lt; arr[i].dp[k - cost] + weight)</span><br><span class="line">                &#123;</span><br><span class="line">                    arr[i].dp[k] = arr[i].dp[k - cost] + weight;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i].num = <span class="number">0</span>; <span class="comment">// 重置组内方案数，重新统计</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - arr[i].mainCost; j++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="comment">// 如果这个价值在之前已经记录过，由于花费越往后越高，不必再记录</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i].mp.count(arr[i].dp[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没记录过且价值不为0</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i].dp[j])</span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="comment">// 记得买附件一定要买主件，所以还要加上主件的价值和花费</span></span><br><span class="line">                arr[i].attachCost[arr[i].num] = j + arr[i].mainCost;</span><br><span class="line">                arr[i].attachWeight[arr[i].num] = arr[i].dp[j] + arr[i].mainWeight;</span><br><span class="line">                arr[i].mp[arr[i].dp[j]] = <span class="number">1</span>; <span class="comment">// 记录</span></span><br><span class="line">                arr[i].num++; <span class="comment">// 方案数加一</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后还要几得把只买一个主件的方案加进去</span></span><br><span class="line">        arr[i].attachWeight[arr[i].num] = arr[i].mainWeight;</span><br><span class="line">        arr[i].attachCost[arr[i].num] = arr[i].mainCost;</span><br><span class="line">        arr[i].num++;</span><br><span class="line">        arr[i].mp.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分组背包</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; arr[i].num; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; arr[i].attachCost[k])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &lt; dp[j - arr[i].attachCost[k]] + arr[i].attachWeight[k])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] = dp[j - arr[i].attachCost[k]] + arr[i].attachWeight[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="求方案种数"><a href="#求方案种数" class="headerlink" title="求方案种数"></a>求方案种数</h1><p>另外开一个一维数组记录方案种数，同样利用滚动数组，有<code>num[j] += num[j - cost[i]]</code>表示考虑前i件时，背包容量为j的方案种数。初始化时只需要设num[0]= 1表示什么都不选也有一种方法。更新方式和对应的背包更新一样，以下以01背包为例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= cost[i]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] += dp[j - cost[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="如果给的值的范围变了"><a href="#如果给的值的范围变了" class="headerlink" title="如果给的值的范围变了"></a>如果给的值的范围变了</h1><p>以上算法的复杂度为O(mn)为背包容量乘以物品种数，但如果给的背包容量可能非常大，但物品的价值范围较小的话上面的算法的时间复杂度显然不够了，这时就要换一种思路：一价值为基础来算花费。定义dp[i][j]表示考虑前i个物品时，价值为j时的最小重量，则有状态转移方程：<code>dp[i][j] = min(dp[i][j], dp[i][j - weight[i]] + cost[i])</code>，这样初始化的时候就要改一下了，全部初始化为INF，表示价值为j目前什么都不考虑是做不到的，或者说要无限个空物品才可以达到；但是j = 0是可达的，方案就是什么都不选，所以dp[0] = 0</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n为物品种数，m为背包容量，maxV为所有物品中的最大价值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> maxV)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fill(dp, dp + n * maxV, INF);</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = n * maxV; j &gt;= weight[i]; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[j] = min(dp[j], dp[j - weight[i]] + cost[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 答案就是最小花费小于背包容量中下标最大的</span></span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n * maxV; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dp[i] &lt;= m)</span><br><span class="line">		&#123;</span><br><span class="line">			ans = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="如果给的物品的价值不是定值"><a href="#如果给的物品的价值不是定值" class="headerlink" title="如果给的物品的价值不是定值"></a>如果给的物品的价值不是定值</h1><p>如果价值不是定值，如这题<a href="https://www.luogu.org/problemnew/show/P1417" target="_blank" rel="noopener">洛谷 P1417</a>，价值和时间有关，就不能直接套用01背包的模版了。01背包遍历物品从1到n表示的是每个物品在轮到被选择之前的所有选择都是正确的，由于01背包价值的固定性，并不在乎选择的顺序。但是这题不同，这题如果之前的选择不够优，就有可能在选择的时候由于暂时的dp值更大而而导致了如贪心算法一样的片面性，所以我们要保证在选择之前的正确性才可以开始按顺序选择。<br>考虑相邻两物品x,y。假设现在已经耗费p的时间，那么x、y先后做的价值：<br><code>a[x] - (p + c[x]) * b[x] + a[y] - (p + c[x] + c[y]) * b[y]</code>(先做x后做y)<br><code>a[y] - (p + c[y]) * b[y] + a[x] - (p + c[y] + c[x]) * b[x]</code>(先做y后做x)<br>为了让先考虑x再考虑y的顺序是最优解，我们就要让先x后y的价值更大，让1式&gt;2式解得：<code>c[x] * b[y] &lt; c[y] * b[x]</code>，先i项已经考虑过的物品就可以合成一个物品，所以我们只需要按这个顺序对物品进行排序，再按顺序求解就可以得到最优解<br>P.S. 最大值不一定出现在最大时间处</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll a, b, c;</span><br><span class="line">&#125; dish[MAXN];</span><br><span class="line">ll dp[MAXT];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(info a, info b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.c * b.b &lt; a.b * b.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, n;</span><br><span class="line">    scTwoInt(t, n);</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;dish[i].a);</span><br><span class="line">    &#125;</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;dish[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;dish[i].c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(dish + <span class="number">1</span>, dish + <span class="number">1</span> + n, cmp);</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        repME(j, t, dish[i].c)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j - dish[i].c] + dish[i].a - dish[i].b * j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    repLE(i, <span class="number">1</span>, t)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = max(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://http//www.laughingtree.cn/2019/11/09/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LaughingTree">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">背包问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-11-09 00:37:16 / Modified: 00:49:05" itemprop="dateCreated datePublished" datetime="2019-11-09T00:37:16+08:00">2019-11-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/" itemprop="url" rel="index">
                    <span itemprop="name">ACM</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/Dynamic-Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Dynamic Programming</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>物品n种，背包最大容量为m，求背包能装的最大价值</p>
<h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1><p>01背包的特点就是每一件物品要么选，要么不选<br>定义状态dp[i][j]表示的是只考虑前i个物品当最大背包容量为j时能装的最大价值<br>对于第i个物品，如果选的话就是<code>dp[i - 1][j - cost[i]] + weight[I]</code>    ，如果不选的话就是dp[i - 1][j]。就可以得到状态转移方程：<code>dp[i][j] = max(dp[i - 1][j - cout[i]] + weight[i], dp[i - 1][j])</code><br>此时的时间复杂度是O(n <em> m)， 空间复杂度为O(n </em> m)<br>我们观察得：每次利用的dp数组仅仅是上一行的前半段，dp[i][j]要用的只有dp[i - 1][j - cout[i]]，再上一行，再后一个都不用。就可以想到对空间的优化——利用滚动数组，从后往前更新<br>初始化时，只需全部置为0即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> cost weight;</span><br><span class="line">&#125; things[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zeroOne</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= things[i].cost; j--) <span class="comment">//j - things[i].cost大于等于0才有意义</span></span><br><span class="line">		&#123;</span><br><span class="line">			dp[j] = max(dp[j - things[i].cost] + things[i].weight, dp[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>进阶问题</strong>：如果背包一定要装满？dp数组除了dp[0]外都初始化为-INF</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zeroOne</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, -INF, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= things[i].cost; j--) <span class="comment">//j - things[i].cost大于等于0才有意义</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (dp[j] &lt; dp[j - things[i].cost] + things[i].weight)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[j] = dp[j - things[i].cost] + things[i].weight</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><p>完全背包的特点就是每件物品的个数都是不限量的<br>思考01背包为什么不从前往后遍历：假如在dp[k]的时候考虑过了第i件之后，在dp[k + cost[i]]还会再考虑一次第i件，所以从前往后遍历的问题就是重复考虑，01背包是不允许重复的，但完全背包的特点就是重复。所以完全背包可以从前往后遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = things[i].cost; j &lt;= m; j++) <span class="comment">//j - things[i].cost大于等于0才有意义</span></span><br><span class="line">		&#123;</span><br><span class="line">			dp[j] = max(dp[j - things[i].cost] + things[i].weight, dp[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h1><p>多重背包就是每一种物品的个数不定，可能只有一个，也可能有多个<br><strong>朴素算法</strong>：把每一个物品都当成是一个独立的物种，变为01背包<br><strong>优化</strong>：朴素算法在物品个数多的时候时间复杂度太高，我们可以利用二进制压缩状态。例如第i种物品有x个，每个价值y。我们就可以合成1个价值y，2个价值2y，4个价值4y，我们就可以通过取不同的个数的组合，取得所有的个数可能</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> &amp; n, <span class="keyword">int</span> num, <span class="keyword">int</span> val, <span class="keyword">int</span> cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> bind = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		things[n].cost = bind * cost;</span><br><span class="line">		things[n].weight = bind * val;</span><br><span class="line">		n++;</span><br><span class="line">		num -= bind;</span><br><span class="line">		bind &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(num &lt; bind)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(num)</span><br><span class="line">	&#123;</span><br><span class="line">		things[n].cost = num * cost;</span><br><span class="line">		things[n].weight = num * val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二维价值背包"><a href="#二维价值背包" class="headerlink" title="二维价值背包"></a>二维价值背包</h1><p>每一件物品都有一个费用，两个价值，要求两个价值的最大/最小选法。二维费用的价值一般会有一个优先级别，即在价值1最大的情况下，如果价值1相等，就取价值2最大的<br>类似01背包，给dp数组加一维，dp[i][j]表示在背包容量为i，价值1为j时，价值2的值。仿照01背包，遍历容量时要倒序遍历，但遍历价值1的值的时候不必倒序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cost[maxn], value1[maxn], value2[maxn], dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twoDValue</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> value1Limit)</span> <span class="comment">//n为物品种数，m为背包容量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt; <span class="number">0</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = value1[i]; k &lt; value1Limit; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[j][k] = max(dp[j][k], dp[j - cost[i]][k - value1[i]]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h1><p>分组背包的特点就是所有的物品被分入了若干组中，选的时候每个组至多只能选一件。我们可以把分组背包转化为01背包，每一个组变为01背包中的一个物品，然后尝试从中选择一件物品得到的最大价值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> num; <span class="comment">//这个组内的物品个数</span></span><br><span class="line">	<span class="keyword">int</span> weight[MAXN], cost[MAXN];</span><br><span class="line">&#125; arr[MAXK];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">grouped</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> <span class="comment">// k为组数，m为容量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; arr[i].num; l++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (j &lt; arr[i].cost[l])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				dp[j] = max(dp[j], dp[j - arr[i].cost[l]] + arr[i].weight[l]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="有依赖的背包"><a href="#有依赖的背包" class="headerlink" title="有依赖的背包"></a>有依赖的背包</h1><p>有依赖背包的特点就是有主件和附件之分，要买附件就一定要买主件，且不存在某种物品既依赖于一个物体又被另一个物体依赖。对于每一个主件及其附件的组合中，可以是只买主件、一个主件加一个附件……而且这其中只能选择一个方案加入最后的方案，就发现可以把每一个主件内的组合作为一个组，改变为上面的分组背包。但是这样每一个组内的物品种数为2^num^ + 1件(num为附件个数)，导致复杂度有点高，但易知，对于同样花费的物品，我们只会选择其中价值最高的那种方案，所以我们可以对附件做一个01背包，再转化为分组背包求解。有时还可以优化：相同价值的物品，我们只会选择花费最小的那种，可以省下更多的空间，装更多的价值<br>模版题：<a href="https://www.luogu.org/problemnew/show/P1064" target="_blank" rel="noopener">洛谷 P1064</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mainObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">// 附件个数</span></span><br><span class="line">    <span class="keyword">int</span> mainWeight, mainCost; <span class="comment">// 主件的价值和花费</span></span><br><span class="line">    <span class="keyword">int</span> attachWeight[MAXM], attachCost[MAXM];</span><br><span class="line">    <span class="comment">// 先存储的是附件的价值和花费，01背包处理后变为该主件为代表的组内的选择方案</span></span><br><span class="line">    <span class="keyword">int</span> dp[MAXM]; <span class="comment">// 01背包记录</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp; <span class="comment">// 记录当前价值是否已经记录过</span></span><br><span class="line">&#125; arr[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rely</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> n)</span> <span class="comment">// num为主件个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 01背包</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) <span class="comment">// 对每一个主件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].num == <span class="number">0</span>) <span class="comment">// 假如没有附件，该组别就只要加一个主件的方案</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr[i].attachWeight[<span class="number">0</span>] = arr[i].mainWeight;</span><br><span class="line">            arr[i].attachCost[<span class="number">0</span>] = arr[i].mainCost;</span><br><span class="line">            arr[i].num++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        clr(arr[i].dp, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 对每一个附件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].num; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cost = arr[i].attachCost[j];</span><br><span class="line">            <span class="keyword">int</span> weight = arr[i].attachWeight[j];</span><br><span class="line">            <span class="comment">// 注意！要给主件留出空间，所以k从n - 主件花费开始</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = n - arr[i].mainCost; k &gt;= cost; k--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i].dp[k] &lt; arr[i].dp[k - cost] + weight)</span><br><span class="line">                &#123;</span><br><span class="line">                    arr[i].dp[k] = arr[i].dp[k - cost] + weight;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i].num = <span class="number">0</span>; <span class="comment">// 重置组内方案数，重新统计</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - arr[i].mainCost; j++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="comment">// 如果这个价值在之前已经记录过，由于花费越往后越高，不必再记录</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i].mp.count(arr[i].dp[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没记录过且价值不为0</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i].dp[j])</span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="comment">// 记得买附件一定要买主件，所以还要加上主件的价值和花费</span></span><br><span class="line">                arr[i].attachCost[arr[i].num] = j + arr[i].mainCost;</span><br><span class="line">                arr[i].attachWeight[arr[i].num] = arr[i].dp[j] + arr[i].mainWeight;</span><br><span class="line">                arr[i].mp[arr[i].dp[j]] = <span class="number">1</span>; <span class="comment">// 记录</span></span><br><span class="line">                arr[i].num++; <span class="comment">// 方案数加一</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后还要几得把只买一个主件的方案加进去</span></span><br><span class="line">        arr[i].attachWeight[arr[i].num] = arr[i].mainWeight;</span><br><span class="line">        arr[i].attachCost[arr[i].num] = arr[i].mainCost;</span><br><span class="line">        arr[i].num++;</span><br><span class="line">        arr[i].mp.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分组背包</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; arr[i].num; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; arr[i].attachCost[k])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &lt; dp[j - arr[i].attachCost[k]] + arr[i].attachWeight[k])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] = dp[j - arr[i].attachCost[k]] + arr[i].attachWeight[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="求方案种数"><a href="#求方案种数" class="headerlink" title="求方案种数"></a>求方案种数</h1><p>另外开一个一维数组记录方案种数，同样利用滚动数组，有<code>num[j] += num[j - cost[i]]</code>表示考虑前i件时，背包容量为j的方案种数。初始化时只需要设num[0]= 1表示什么都不选也有一种方法。更新方式和对应的背包更新一样，以下以01背包为例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= cost[i]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] += dp[j - cost[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="如果给的值的范围变了"><a href="#如果给的值的范围变了" class="headerlink" title="如果给的值的范围变了"></a>如果给的值的范围变了</h1><p>以上算法的复杂度为O(mn)为背包容量乘以物品种数，但如果给的背包容量可能非常大，但物品的价值范围较小的话上面的算法的时间复杂度显然不够了，这时就要换一种思路：一价值为基础来算花费。定义dp[i][j]表示考虑前i个物品时，价值为j时的最小重量，则有状态转移方程：<code>dp[i][j] = min(dp[i][j], dp[i][j - weight[i]] + cost[i])</code>，这样初始化的时候就要改一下了，全部初始化为INF，表示价值为j目前什么都不考虑是做不到的，或者说要无限个空物品才可以达到；但是j = 0是可达的，方案就是什么都不选，所以dp[0] = 0</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n为物品种数，m为背包容量，maxV为所有物品中的最大价值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> maxV)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fill(dp, dp + n * maxV, INF);</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = n * maxV; j &gt;= weight[i]; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[j] = min(dp[j], dp[j - weight[i]] + cost[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 答案就是最小花费小于背包容量中下标最大的</span></span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n * maxV; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dp[i] &lt;= m)</span><br><span class="line">		&#123;</span><br><span class="line">			ans = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="如果给的物品的价值不是定值"><a href="#如果给的物品的价值不是定值" class="headerlink" title="如果给的物品的价值不是定值"></a>如果给的物品的价值不是定值</h1><p>如果价值不是定值，如这题<a href="https://www.luogu.org/problemnew/show/P1417" target="_blank" rel="noopener">洛谷 P1417</a>，价值和时间有关，就不能直接套用01背包的模版了。01背包遍历物品从1到n表示的是每个物品在轮到被选择之前的所有选择都是正确的，由于01背包价值的固定性，并不在乎选择的顺序。但是这题不同，这题如果之前的选择不够优，就有可能在选择的时候由于暂时的dp值更大而而导致了如贪心算法一样的片面性，所以我们要保证在选择之前的正确性才可以开始按顺序选择。<br>考虑相邻两物品x,y。假设现在已经耗费p的时间，那么x、y先后做的价值：<br><code>a[x] - (p + c[x]) * b[x] + a[y] - (p + c[x] + c[y]) * b[y]</code>(先做x后做y)<br><code>a[y] - (p + c[y]) * b[y] + a[x] - (p + c[y] + c[x]) * b[x]</code>(先做y后做x)<br>为了让先考虑x再考虑y的顺序是最优解，我们就要让先x后y的价值更大，让1式&gt;2式解得：<code>c[x] * b[y] &lt; c[y] * b[x]</code>，先i项已经考虑过的物品就可以合成一个物品，所以我们只需要按这个顺序对物品进行排序，再按顺序求解就可以得到最优解<br>P.S. 最大值不一定出现在最大时间处</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll a, b, c;</span><br><span class="line">&#125; dish[MAXN];</span><br><span class="line">ll dp[MAXT];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(info a, info b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.c * b.b &lt; a.b * b.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, n;</span><br><span class="line">    scTwoInt(t, n);</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;dish[i].a);</span><br><span class="line">    &#125;</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;dish[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;dish[i].c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(dish + <span class="number">1</span>, dish + <span class="number">1</span> + n, cmp);</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        repME(j, t, dish[i].c)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j - dish[i].c] + dish[i].a - dish[i].b * j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    repLE(i, <span class="number">1</span>, t)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = max(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二维价值背包-1"><a href="#二维价值背包-1" class="headerlink" title="二维价值背包"></a>二维价值背包</h1><p><a href="https://vjudge.net/problem/POJ-1015" target="_blank" rel="noopener">POJ 1015</a><br>把所有人获得的得分的d - p作为价值1，d + p作为价值2，每个人的费用都是1。价值1的范围是[-20m, 20m]，所以为了防止dp数组的第二维访问错误，我们要把所有的价值1加20m。又要记录路径，我们可以利用一个二维的vector数组来存储路径，每对一个元素更新值的时候就更新对应的vector</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">20</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXSUB = <span class="number">800</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXM][MAXSUB], diff[MAXN], sum[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path[MAXM][MAXSUB];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, d, p, kase = <span class="number">1</span>;;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) &amp;&amp; n &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        rep(i, <span class="number">0</span>, m + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rep(j, <span class="number">0</span>, MAXSUB)</span><br><span class="line">            &#123;</span><br><span class="line">                path[i][j].<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        rep(i, <span class="number">0</span>, n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p, &amp;d);</span><br><span class="line">            diff[i] = p - d;</span><br><span class="line">            sum[i] = p + d;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        clr(dp, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> add = <span class="number">20</span> * m;</span><br><span class="line">        dp[<span class="number">0</span>][add] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span>  k = diff[i]; k &lt;= <span class="number">2</span> * add; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(k &lt; <span class="number">0</span> || k - diff[i] &gt; <span class="number">2</span> * add)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dp[j - <span class="number">1</span>][k - diff[i]] == <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dp[j - <span class="number">1</span>][k - diff[i]] + sum[i] &gt; dp[j][k])</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[j][k] = dp[j - <span class="number">1</span>][k - diff[i]] + sum[i];</span><br><span class="line">                        <span class="comment">//更新路径</span></span><br><span class="line">                        path[j][k] = path[j - <span class="number">1</span>][k - diff[i]];</span><br><span class="line">                        path[j][k].push_back(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(dp[m][add + state] == <span class="number">-1</span> &amp;&amp; dp[m][add - state] == <span class="number">-1</span>)  <span class="comment">//找出合法的最小价值1</span></span><br><span class="line">        &#123;</span><br><span class="line">            state++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//更新成更大的那个价值2</span></span><br><span class="line">        <span class="keyword">if</span>(dp[m][add + state] &lt; dp[m][add - state])</span><br><span class="line">        &#123;</span><br><span class="line">            state = add - state;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            state = add + state;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ansD = (dp[m][state] - (state - add)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ansP = (dp[m][state] + (state - add)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Jury #%d\n"</span>, kase++);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Best jury has value %d for prosecution and value %d for defence:\n"</span>, ansP, ansD);</span><br><span class="line">        rep(i, <span class="number">0</span>, path[m][state].<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>, path[m][state][i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="背包的本质"><a href="#背包的本质" class="headerlink" title="背包的本质"></a>背包的本质</h1><p>背包问题的本质就是给定一系列物品，对于物品的选与不选的问题。而且物品的选择不会影响到下一个物品的选择范围(就算是分组背包和依赖背包也可以经过变化，变为不影响选择的问题，主要是要与数塔问题进行区分)<br>例题：<a href="https://www.luogu.org/problemnew/show/P1282" target="_blank" rel="noopener">洛谷 P1282</a><br>这题每一套多米诺骨牌就是一个物品，选与不选的问题就是翻与不翻的问题，这就可以转化为一个01背包。但是要注意的是这题翻与不翻可能会出现负价值，所以这题不能用滚动数组(01背包能用滚动数组是因为只与两维都不大于当前的值有关，但这题负价值的存在就导致了第二维还与大于当前的值有关)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">12005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXA = <span class="number">6005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ori[MAXM][<span class="number">2</span>], dp[MAXM][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    scInt(n);</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        scTwoInt(ori[i][<span class="number">0</span>], ori[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    fill(dp[<span class="number">0</span>], dp[<span class="number">0</span>] + MAXN, INF);</span><br><span class="line">    dp[<span class="number">0</span>][MAXA] = <span class="number">0</span>;</span><br><span class="line">    repLE(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        repLE(j, <span class="number">-5000</span>, <span class="number">5000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> dis = ori[i][<span class="number">0</span>] - ori[i][<span class="number">1</span>];</span><br><span class="line">            dp[i][j + MAXA] = min(dp[i - <span class="number">1</span>][j - dis + MAXA], dp[i - <span class="number">1</span>][j + dis + MAXA] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    repLE(i, <span class="number">0</span>, <span class="number">5000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = min(dp[n][i + MAXA], dp[n][-i + MAXA]);</span><br><span class="line">        <span class="keyword">if</span>(ans &lt;= <span class="number">1e3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h1><p><a href="https://ac.nowcoder.com/acm/contest/911/H" target="_blank" rel="noopener">新疆省赛-H</a><br>这题对每个数只需要考虑2和5的因数个数，把个数记为费用1，因数5的个数记为费用2，求能得到的最多因数2的个数。费用1的界就是k，费用2的界是前i个数中因数5的个数的总和</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repLess(ele, init, lim) for(int ele = init; ele &lt; lim; ele++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repLE(ele, init, lim) for(int ele = init; ele &lt;= lim; ele++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repMore(ele, init, lim) for(int ele = init; ele &gt; lim; ele--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repME(ele, init, lim) for(int ele = init; ele &gt;= lim; ele--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> scInt(to) scanf(<span class="meta-string">"%d"</span>, &amp;to)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> scTwoInt(one, two) scanf(<span class="meta-string">"%d%d"</span>, &amp;one, &amp;two)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> scThreeInt(one, two, three) scanf(<span class="meta-string">"%d%d%d"</span>, &amp;one, &amp;two, &amp;three)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr, init) memset(arr, init, sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc ((o &lt;&lt; 1) + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc (o &lt;&lt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">205</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">num</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll a;</span><br><span class="line">    <span class="keyword">int</span> matchFive, matchEven;</span><br><span class="line">&#125; arr[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXN][<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k))</span><br><span class="line">    &#123;</span><br><span class="line">        repLess(i, <span class="number">0</span>, n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;arr[i].a);</span><br><span class="line">            arr[i].matchFive = arr[i].matchEven = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (arr[i].a % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[i].matchEven++;</span><br><span class="line">                arr[i].a /= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (arr[i].a % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[i].matchFive++;</span><br><span class="line">                arr[i].a /= <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        clr(dp, -INF);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        repLess(i, <span class="number">0</span>, n)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += arr[i].matchFive;</span><br><span class="line">            repME(j, k, <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                repME(l, sum, arr[i].matchFive)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j][l] = max(dp[j - <span class="number">1</span>][l - arr[i].matchFive] + arr[i].matchEven, dp[j][l]);</span><br><span class="line">                    ans = max(min(l, dp[j][l]), ans);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://http//www.laughingtree.cn/2019/11/09/DP%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LaughingTree">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/DP%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">DP之子序列问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-11-09 00:35:47 / Modified: 00:37:35" itemprop="dateCreated datePublished" datetime="2019-11-09T00:35:47+08:00">2019-11-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/" itemprop="url" rel="index">
                    <span itemprop="name">ACM</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/Dynamic-Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Dynamic Programming</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="最大m段子序列和"><a href="#最大m段子序列和" class="headerlink" title="最大m段子序列和"></a>最大m段子序列和</h1><p><strong>问题描述</strong>：给定一个数列，从中选取m段互不重叠的子段，使那m个子段的和最大</p>
<p><strong>解决</strong>：定义状态dp[i][j]表示由前j个元素分成i段的最优解且是以num[j]结尾。因为是以num[j]结尾，所以只有两种可能，即num[j]属于最后一个子段或独立成为一个子段。又若独立称为一个子段的话前面至少要有i - 1个元素，要不然就做不到i - 1个互不重叠的子段。则有状态转移方程<code>dp[i][j] = max(dp[i][j - 1] + num[j], dp[i - 1][k] + num[j](i - 1 ≤ k &lt; j))</code></p>
<p><strong>优化</strong>：<br>&emsp;时间优化：在规划过程中，时间主要消耗在寻找dp[i - 1][k]的最大值，我们可以在计算dp[i - 1]那行的时候就把这个最大值算好，记录在preMax数组中<br>&emsp;空间优化：我们发现和背包问题类似，preMax数组只对一行有效，故我们可以用完一次就更新一次，使之适用于下一行，这样我们就只需要一个一维数组就可以解决问题，因此dp数组也可以缩小到一维</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num[maxn], dp[maxn], preMax[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> <span class="comment">//n为数字个数，m为子段数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="built_in">memset</span>(preMax, <span class="number">0</span>, <span class="keyword">sizeof</span>(preMax));</span><br><span class="line">	<span class="keyword">int</span> maxmun;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		maxmun = -INF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[j] = <span class="built_in">max</span>(dp[j - <span class="number">1</span>], preMax[j - <span class="number">1</span>]) + num[j]; </span><br><span class="line">			preMax[j - <span class="number">1</span>] = maxmun;</span><br><span class="line">			maxmun = <span class="built_in">max</span>(dp[j], mx);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxmun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最大连续子序列和"><a href="#最大连续子序列和" class="headerlink" title="最大连续子序列和"></a>最大连续子序列和</h1><p><strong>问题描述</strong>：给定一个数列，求其中连续的一段子序列的和的最大值。和上一题的区别就是子序列要求连续<br><strong>暴力求解</strong>：枚举所有的连续子序列，找出其中的最大值。这种解法要枚举所有的区间开始i和结束j，还要把他们都加起来，复杂度是O(n^3^)，有一个优化的方法：定一个数组sum，sum[i]表示的是前i个元素的和。这样区间[i, j]的和就可以表示为<code>sum[j] - sum[i - 1]</code>，就只需要枚举所有的i和j，只要O(n^2^)的时间<br><strong>DP求解</strong>：定义状态dp[i]表示的是以第i个元素结尾的最大连续子序列和。所以对于第i个元素只有两种情况<br>&emsp;单独成为一个子序列，和为num[i]<br>&emsp;和前面的一起组成一个子序列，因为num[i]是固定的，所以要最大和就要之前的子序列和最大，又要连续的子序列，所以就要以num[i - 1]结尾，即dp[i - 1] + num[i]<br>所以有状态转移方程：<code>dp[i] = max(num[i], dp[i - 1] + num[i])</code><br>初始时只需要使<code>dp[0] = num[0]</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num[maxn], dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans;</span><br><span class="line">	ans = dp[<span class="number">0</span>] = num[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i] = <span class="built_in">max</span>(num[i], dp[i - <span class="number">1</span>] + num[i]);</span><br><span class="line">		<span class="keyword">if</span>(dp[i] &gt; ans)</span><br><span class="line">		&#123;</span><br><span class="line">			ans = dp[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h1><p><strong>问题描述</strong>：给定一个数列，求出一个子序列，使这个子序列中后一个元素都比之前的数大。求这样的子序列的长度最大值<br><strong>解决</strong>：<br>维护一维数组dp[i]表示以num[i]结尾的最长上升子序列的长度。易知，dp数组应该初始化为1.<br>&emsp;<strong>暴力枚举法O(n^2^)</strong>：对每一个结尾，枚举之前的所有可能长度，取其中最大值加一。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num[maxn], dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(num[j] &lt; num[i] &amp;&amp; dp[i] &lt; dp[j] + <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力枚举虽然暴力，但在有些题中必须得用这种方式，如：<a href="https://vjudge.net/problem/HDU-1069" target="_blank" rel="noopener">HDOJ 1069</a><br>这题把每块砖都按长宽高不同排序分割为六个不同状态，并按长宽中某一种排序。排序后不管怎么选，那一种一定是满足要求的。但排好之后的另一种还是无序的，所以就要从中选出权值最大的递增数列。因为要求两维都是单调的，所以只能暴力枚举。</p>
<p>&emsp;<strong>优化O(nlogn)</strong>：定义dp[i]的含义为长度为i的递增序列的最小结尾元素。这时dp数组的初始化就要为INF，dp数组的第一个元素就是num原数组的第一个元素。因为是最长上升子序列，所以dp数组一定有序，所以我们就可以利用二分法查找不大于num[i]的最长序列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(dp, dp + n, INF);</span><br><span class="line">    dp[<span class="number">1</span>] = num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i] &gt; dp[len])</span><br><span class="line">        &#123;</span><br><span class="line">            dp[++len] = num[i];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = len + <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(dp[mid] &gt; num[i])</span><br><span class="line">            &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[l] = <span class="built_in">min</span>(num[i], dp[l]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;<strong>路径记录</strong>：每次更新的时候都记录一下前一个被选择的数字，然后递归输出即可</p>
<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p>定义一个二维数组dp，第一维表示第一个数组的前i位，第二维表示第二个数组的前j位，即dp[i][j]表示的是第一个数组的前i位和第二个数组的前j位的最长公共子序列。这时就有两种情况：<br>&emsp;如果<code>num1[I] == num2[j]</code>，那<code>dp[i][j] = dp[i - 1][j - 1] + 1</code>，即如果相等的话，dp[i][j]就是把这两个元素不考虑的第一个数列的前i - 1项和第二个数列的前j - 1项的公共子序列加1<br>&emsp;如果<code>num1[i] != num2[j]</code>，那<code>dp[i][j] = max(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])</code>，即不相等的话dp[i][j]就是把第一个数列的第i项裁掉或把第二个数列的第j项裁掉或都裁掉的最大值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1[maxn], num2[maxn], dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCS</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(num1[i] == num2[j])</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最长单调子序列"><a href="#最长单调子序列" class="headerlink" title="最长单调子序列"></a>最长单调子序列</h1><p><a href="https://vjudge.net/problem/HDU-1257" target="_blank" rel="noopener">HDOJ 1257</a><br>这题就是最长递减子序列的一个变形：定义dp数组，使dp[i]表示的是第i个发射台发射的上一个炮弹的高度。对于每一枚导弹，要找到可以拦截且前一个导弹高度最小的系统去拦截。我们初始只用一个系统，每次无法拦截的时候就新增一个系统，由此可知dp数组一定是单调增长的，所以只需要从前往后遍历，第一个可以拦截的系统即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">0</span>] = INF;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> inp;</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;inp);</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; cnt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &gt;= inp)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] = inp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == cnt)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[cnt] = inp;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://http//www.laughingtree.cn/2019/11/09/%E6%8B%93%E5%B1%95KMP%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LaughingTree">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/%E6%8B%93%E5%B1%95KMP%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">拓展KMP算法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-11-09 00:34:03 / Modified: 00:34:55" itemprop="dateCreated datePublished" datetime="2019-11-09T00:34:03+08:00">2019-11-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/" itemprop="url" rel="index">
                    <span itemprop="name">ACM</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/String/" itemprop="url" rel="index">
                    <span itemprop="name">String</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>EX-KMP算法是在KMP算法的基础上改变的</p>
<h1 id="算法目的"><a href="#算法目的" class="headerlink" title="算法目的"></a>算法目的</h1><p>求出主串每一个后缀和模式串的最长公共前缀，也可以理解为主串从每一个位置开始到结尾的子串和模式串的最长公共前缀</p>
<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>我们用一个数组extend来保存结果，受到KMP算法的启发，我们对模式串进行自匹配，得到nex数组。在拓展KMP算法中，预处理和主算法之间几乎没有区别，只是改了比较的两个数组，自匹配是模式串和模式串匹配，主算法是主串和模式串匹配</p>
<h1 id="extend匹配方法"><a href="#extend匹配方法" class="headerlink" title="extend匹配方法"></a>extend匹配方法</h1><p>exKMP和KMP的核心思想一样，都是利用之前的匹配结果来避免不必要的匹配过程。假设我们已经完成了主串第k位及其以前的匹配，我们要开始匹配主串的第k+1位和模式串的第0位开始的串。<br>1、因为我们要利用以前的匹配结果，所以以前的匹配结果越远越好，又我们是从主串的第k+1位开始往后匹配，我们只需要主串上的最后匹配位置P越靠后就好，而无需管该次匹配的开始位置p0在哪，不需使该次匹配的长度最长<br>2、易知k+1到p~0~点距离是k+1-p~0~，我们假设第k+1位开始匹配的最长公共前缀的长度是len，则我们为了利用之前的结果，得知主串<strong>S(p~0~..&lt;p~0~+extend[p~0~]) = 模式串T(0..&lt;extend[p~0~])</strong>。又有<strong>T(0..&lt;nex[k-p~0~+1]) = T(k-p~0~+1..&lt;k-p~0~+1+nex[k-p~0~+1]</strong>，我们在模式串和主串匹配时把模式串前移k-p~0~+1，使k+1与p~0~重合<br>3、我们可以得到<strong>S(p~0~..&lt;p~0~+nex[k-p~0~+1])=T(0…nex[k-p~0~+1])=T(k-p~0~+1…k-p~0~+nex[k-p~0~+1])=S(k+1…k+nex[k-p~0~+1])</strong>。这就够了吗？不是的，我们可以注意到，在推导过程中，在最后<strong>S(k+1…k+nex[k-p~0~+1])</strong>中，最远可以到<strong>k+nex[k-p~0~+1]</strong>，如果这个值已经超出了我们的已匹配范围(<strong>p~0~+extend[p~0~]-1</strong>)就不能利用结果<br>故我们得出若<strong>k+nex[k-p~0~+1]&lt;p~0~+extend[p~0~]</strong>，则<strong>T(0…nex[k-p~0~+1])=S(k+1…k+nex[k-p~0~+1])</strong>，即<strong>第k+1位的匹配长度为nex[k-p~0~+1]</strong><br>4、若<strong>nex[k-p~0~+1] &gt;= extend[p~0~]</strong>，我们只需要从P+1开始匹配，并更新P和p~0~</p>
<h1 id="nex匹配方法"><a href="#nex匹配方法" class="headerlink" title="nex匹配方法"></a>nex匹配方法</h1><p>匹配过程中的主串和模式串都是主算法中的模式串，extend和nex数组都是主算法中的nex</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nex[maxn], ex[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildNex</span><span class="params">(<span class="keyword">int</span> modeLen, <span class="built_in">string</span> modeString)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mainPos = <span class="number">0</span>, p0;</span><br><span class="line">    nex[<span class="number">0</span>] = modeLen;</span><br><span class="line">    p0 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(mainPos + <span class="number">1</span> &lt; modeLen &amp;&amp; modeString[mainPos + <span class="number">1</span>] == modeString[mainPos])</span><br><span class="line">    &#123;</span><br><span class="line">        mainPos++;</span><br><span class="line">    &#125;</span><br><span class="line">    nex[<span class="number">1</span>] = mainPos;</span><br><span class="line">    p0 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(mainPos = <span class="number">2</span>; mainPos &lt; modeLen; mainPos++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mainPos + nex[mainPos - p0] &lt; p0 + nex[p0])</span><br><span class="line">        &#123;</span><br><span class="line">            nex[mainPos] = nex[mainPos - p0];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = nex[p0] + p0 - mainPos;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(mainPos + j &lt; modeLen &amp;&amp; modeString[j] == modeString[mainPos + j])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            nex[mainPos] = j;</span><br><span class="line">            p0 = mainPos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildExtend</span><span class="params">(<span class="built_in">string</span> mainString, <span class="built_in">string</span> modeString, <span class="keyword">int</span> mainLen, <span class="keyword">int</span> modeLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    buildNex(mainLen, modeString);</span><br><span class="line">    <span class="keyword">int</span> mainPos = <span class="number">0</span>, p0;</span><br><span class="line">    p0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(mainPos &lt; modeLen &amp;&amp; mainPos &lt; mainLen &amp;&amp; mainString[mainPos] == modeString[mainPos])</span><br><span class="line">    &#123;</span><br><span class="line">        mainPos++;</span><br><span class="line">    &#125;</span><br><span class="line">    ex[<span class="number">0</span>] = mainPos;</span><br><span class="line">    <span class="keyword">for</span>(mainPos = <span class="number">1</span>; mainPos &lt; mainLen; mainPos++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mainPos + ex[mainPos - p0] &lt; p0 + ex[p0])</span><br><span class="line">        &#123;</span><br><span class="line">            ex[mainPos] = nex[mainPos - p0];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = ex[p0] + p0 - mainPos;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(mainPos + j &lt; mainLen &amp;&amp; j &lt; modeLen &amp;&amp; modeString[j] == mainString[mainPos + j])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            ex[mainPos] = j;</span><br><span class="line">            p0 = mainPos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://http//www.laughingtree.cn/2019/11/09/KMP%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="LiyunZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LaughingTree">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/KMP%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">KMP串匹配算法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-09 00:33:20" itemprop="dateCreated datePublished" datetime="2019-11-09T00:33:20+08:00">2019-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-07 09:01:24" itemprop="dateModified" datetime="2020-05-07T09:01:24+08:00">2020-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/" itemprop="url" rel="index">
                    <span itemprop="name">ACM</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ACM/String/" itemprop="url" rel="index">
                    <span itemprop="name">String</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="串匹配问题"><a href="#串匹配问题" class="headerlink" title="串匹配问题"></a>串匹配问题</h1><p>给定两个串，一个是主串，一个是模式串，要求从主串中找到模式串的匹配<br>直观地，很容易就想得到蛮力算法，即一个一个比较，直到找到或匹配结束</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> mainString, modeString;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mainPos = <span class="number">0</span>, modePos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = mainString.length();</span><br><span class="line">    <span class="keyword">int</span> modeLen = modeString.length();</span><br><span class="line">    <span class="keyword">while</span>(mainPos &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mainString[mainPos] == modeString[modePos])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = mainPos + <span class="number">1</span>;</span><br><span class="line">            modePos++;</span><br><span class="line">            <span class="keyword">while</span>(mainString[pos] == modeString[modePos] &amp;&amp; modePos &lt; modeLen)</span><br><span class="line">            &#123;</span><br><span class="line">                pos++;</span><br><span class="line">                modePos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(modePos == modeLen)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                modePos = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mainPos++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><p>先来看一下蛮力算法慢的原因：到一个点匹配失败，可以得出在这个点之前到都是匹配成功的，这样我们就可以通过模式串知道主串在那一段中的信息，利用这些信息，我们就可以提前知道哪些值得匹配，哪些不值得花时间匹配，就可以跳过一些内容，省下时间。而蛮力算法的问题就是没有好好利用我们已知的模式串的信息。<br>于是我们就有了改进的方向——对模式串进行预处理，知道当我们在模式串的第i个点匹配失败时应该跳到第nex[ i ]而不是都回到原点</p>
<h1 id="nex数组"><a href="#nex数组" class="headerlink" title="nex数组"></a>nex数组</h1><p><strong>含义</strong>“：<br>我们思考一下为什么我们可以直接从nex[ i ]开始匹配而不需像蛮力算法一样，从头开始？因为跳过的那些已经匹配了。那那些是和什么匹配了？首先想一下，匹配失败了以后，主串上的指针是不同的，我们所做的操作只是移动了模式串让nex[ i ]去和主串之前失败的地方匹配。所以移过去了以后，模式串跳过的那些前缀就和主串中失败点之前到一段等长后缀匹配。又主串失败点之前的内容已经和模式串的失败点之前的子串匹配所以实际就是模式串在失败点之前的子串的一个前缀和后缀在匹配，而跳过的长度就是匹配前缀的长度，nex[ i ]存储的值就是这个长度。<br><img src="/img/KMP串匹配算法01.jpg" width="80%"><br><strong>构造</strong>：<br>构造就是模式串自匹配的过程。子匹配时两个指针，一个mainPos指的是主串，一个modePos指的是模式串，虽然两个都指在同一个串中。匹配时有两种情况：<br>&emsp;1、如果主串和模式串匹配，则<code>nex[mainPos] = modeString + 1</code>，因为modePos及其以前的子串已经和mainPos之前的后缀匹配了，所以在这里的最长前缀只能全部取，长度就是modePos+1<br>&emsp;2、如果不匹配，<code>modePos = nex[modePos]</code>，道理同主串和模式串不同时，直到匹配成功<br>为了防止第一个就不匹配，我们设定一个哨兵，在整个字符串的前面，假设这个哨兵可以和任意字符匹配，位置为-1，所以<code>nex[0] = -1</code>，第一个都失败的话就让哨兵去匹配现在的那个点才能成功<br>modePos初始就设为nex[ 0 ] = -1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildNext</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nex[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mainString = <span class="number">0</span>, modeString = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(mainString &lt; str2.length() - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str2[mainString] == str2[modeString] || modeString &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nex[++mainString] = ++modeString;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            modeString = nex[modeString];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="！！！！！nex数组的下标i都是模式串的第i位，而不是主串的第i位"><a href="#！！！！！nex数组的下标i都是模式串的第i位，而不是主串的第i位" class="headerlink" title="！！！！！nex数组的下标i都是模式串的第i位，而不是主串的第i位"></a>！！！！！nex数组的下标i都是模式串的第i位，而不是主串的第i位</h5><h1 id="KMP主算法"><a href="#KMP主算法" class="headerlink" title="KMP主算法"></a>KMP主算法</h1><p>和蛮力算法的区别就是不匹配时<code>modeString = nex[modeString]</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ori = <span class="number">0</span>, cmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len1 = (<span class="keyword">int</span>)str1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = (<span class="keyword">int</span>)str2.length();</span><br><span class="line">    <span class="keyword">while</span>(ori &lt; len1 &amp;&amp; cmp &lt; len2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span> || str1[ori] == str2[cmp])</span><br><span class="line">        &#123;</span><br><span class="line">            ori++;</span><br><span class="line">            cmp++;</span><br><span class="line">            <span class="keyword">if</span>(cmp == str2.length())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cmp = nex[cmp];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>串都是从0开始的</p>
<h1 id="串的周期性"><a href="#串的周期性" class="headerlink" title="串的周期性"></a>串的周期性</h1><p>建立nex数组时，while循环的条件改为<code>mainString &lt; str2.length()</code>，设串长为len，则：<br>&emsp;1、如果<code>nex[len] == 0</code>，则该串毫无循环；<br>&emsp;2、如果有<code>len % (len - nex[len]) == 0</code>，则这是一个循环串，且循环节长度为<code>len - nex[len]</code>，循环次数为<code>len / (len - nex[len])</code>；<br>&emsp;3、否则该串有部分循环，且最少再补<code>(len - nex[len]) - len % (len - nex[len])</code>个元素就可以成为循环<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3746" target="_blank" rel="noopener">HDOJ 3746</a><br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1358" target="_blank" rel="noopener">HDOJ 1358</a></p>
<h1 id="nex数组的妙用"><a href="#nex数组的妙用" class="headerlink" title="nex数组的妙用"></a>nex数组的妙用</h1><p>除了用在KMP查询上，nex数组还可以用在如下方面：<br>&emsp;任意前缀的重复次数：nex[i]可以理解为串的长为nex[i]的前缀在自身上以第i个元素开头，长为nex[i]的子串重合，即前缀重复了一次。所以利用nex数组，我们就可以知道任意前缀的重复次数<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3336" target="_blank" rel="noopener">HDOJ 3336</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LiyunZhang"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">LiyunZhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">173</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liyun Zhang</span>
</div>
<div class="BbeiAn-info">
       浙ICP备 -
    <a target="_blank" href="http://www.miitbeian.gov.cn/" style="color:#000000"  rel="nofollow">19047088号-1</a> <!--a标签中增加nofollow属性，避免爬虫出站。-->|
    <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33011802001835" style="color:#000000;text-decoration:none;padding-left:30px;background:url(https://s1.ax1x.com/2018/09/29/ilmwIH.png) no-repeat left center" rel="nofollow">浙公网安备 33011802001835号</a>      <!--这里将图标作为了背景，以使得能和后面的文字在同一行-->

</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
